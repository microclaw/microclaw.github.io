"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8130],{7735(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/building-microclaw","metadata":{"permalink":"/blog/building-microclaw","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-07-building-microclaw.md","source":"@site/blog/2026-02-07-building-microclaw.md","title":"Building MicroClaw: An Agentic AI Assistant in Rust That Lives in Your Telegram Chats","description":"What if your Telegram chat was a terminal? Not a dumbed-down chatbot that responds with canned text, but an actual AI agent that can run commands on your server, edit your files, search your codebase, browse the web, schedule recurring tasks, and remember what you told it three weeks ago?","date":"2026-02-07T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture"},{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":false,"label":"Telegram","permalink":"/blog/tags/telegram"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"}],"readingTime":6.41,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/building-microclaw","title":"Building MicroClaw: An Agentic AI Assistant in Rust That Lives in Your Telegram Chats","authors":["microclaw"],"tags":["architecture","rust","telegram","agents"]},"unlisted":false,"nextItem":{"title":"MicroClaw Release Notes \u2014 February 2026","permalink":"/blog/release-notes-2026-02"}},"content":"What if your Telegram chat was a terminal? Not a dumbed-down chatbot that responds with canned text, but an actual AI agent that can run commands on your server, edit your files, search your codebase, browse the web, schedule recurring tasks, and remember what you told it three weeks ago?\\n\\nThat\'s MicroClaw -- a Rust implementation of the agentic AI-in-a-chat pattern, connecting Claude to Telegram with full tool execution. It started as a rewrite of nanoclaw (TypeScript/WhatsApp), but was rebuilt from scratch in Rust with a focus on simplicity and additional capabilities.\\n\\n\x3c!-- truncate --\x3e\\n\\n## The idea\\n\\nMost AI chatbot integrations are thin wrappers. They take a message, forward it to an API, and return the response. One turn, no state, no agency.\\n\\nMicroClaw is different. When you send it a message, it enters an agentic loop: Claude receives your message along with a set of tools, decides whether it needs to take action, executes tools if necessary, reads the results, decides if it needs to do more, and keeps going -- up to 25 iterations -- before finally composing a response.\\n\\nAsk it to \\"find all TODO comments in the project and create a summary\\" and it will:\\n\\n1. Run a grep search across your codebase\\n2. Read the matching files for context\\n3. Synthesize the results into a structured summary\\n4. Respond in your Telegram chat\\n\\nAll of that happens in a single message exchange. You send one message, you get back one answer. The multi-step reasoning happens behind the scenes.\\n\\n## Why Rust?\\n\\nThe original nanoclaw is TypeScript. It works. But I wanted something I could deploy as a single static binary with no runtime dependencies. `cargo build --release` gives you one file. Copy it to a server, set three environment variables, and it runs.\\n\\nRust also turned out to be a surprisingly good fit for this kind of project:\\n\\n- Enums for the API protocol. Claude\'s content blocks come in three flavors: text, tool_use, and tool_result. Rust\'s tagged enums with serde map to this perfectly. No stringly-typed checks, no runtime type confusion.\\n- Trait objects for tools. Each tool implements a `Tool` trait. The registry holds `Vec<Box<dyn Tool>>`. Adding a new tool is four lines of wiring.\\n- Async without drama. Tokio + reqwest + teloxide all play nicely together. The entire bot is a single async binary.\\n- Shared state is explicit. `Arc<Database>` makes it clear exactly which components share database access. The scheduler, the tools, and the message handler all hold their own arc -- no hidden global state.\\n\\n## Architecture\\n\\nThe system has eight modules, and the data flows in one direction:\\n\\n```\\nTelegram message\\n       |\\n       v\\n    SQLite (store message, load history)\\n       |\\n       v\\n    System prompt (inject memories + chat_id)\\n       |\\n       v\\n    Claude API -----\x3e tool_use? -----\x3e Execute tool\\n       ^                                    |\\n       |                                    |\\n       +---- feed result back --------------+\\n       |\\n       v\\n    end_turn? --\x3e Send response to Telegram\\n```\\n\\nMeanwhile, running in the background:\\n\\n```\\nScheduler (every 60s)\\n       |\\n       v\\n    Query due tasks from SQLite\\n       |\\n       v\\n    For each: run agentic loop --\x3e send result to chat\\n```\\n\\n### The agentic loop\\n\\nThe heart of MicroClaw lives in one function: `process_with_claude`. Here\'s what it does:\\n\\n1. Load history from SQLite. In private chats, this is the last N messages. In groups, it\'s everything since the bot\'s last reply -- the catch-up mechanism that makes group interactions feel natural.\\n2. Read any saved memories (global and per-chat CLAUDE.md files) and inject them into the system prompt.\\n3. If there\'s an override prompt (from the scheduler), append it as a user message.\\n4. Convert the message history into Claude\'s message format.\\n5. Enter the loop: call the Claude API. If Claude responds with `stop_reason: \\"tool_use\\"`, execute the requested tools, append the results as a `tool_result` message, and call Claude again. If Claude responds with `stop_reason: \\"end_turn\\"`, extract the text and return it.\\n\\nThe loop has a safety cap (default 25 iterations). In practice, most interactions use 0-3 tool calls. Complex tasks like \\"refactor this file\\" might use 5-10.\\n\\n### The typing indicator\\n\\nA small quality-of-life feature that makes a big difference: the typing indicator stays active for the entire duration of processing. A spawned Tokio task sends `ChatAction::Typing` every 4 seconds. When the response is ready, the task is aborted.\\n\\nWithout this, the typing indicator would flash once when the message is received and then disappear, even if Claude is midway through a 10-tool chain. With it, the user always knows the bot is working.\\n\\n### Tools\\n\\nMicroClaw ships with sixteen tools across five categories:\\n\\nFile system: `bash`, `read_file`, `write_file`, `edit_file`, `glob`, `grep`\\n\\nMemory: `read_memory`, `write_memory`\\n\\nWeb: `web_search`, `web_fetch`\\n\\nMessaging: `send_message`\\n\\nScheduling: `schedule_task`, `list_scheduled_tasks`, `pause_scheduled_task`, `resume_scheduled_task`, `cancel_scheduled_task`\\n\\n### Memory\\n\\nTell it \\"remember that I\'m working on project Atlas and the deploy target is staging.example.com\\" and it will write that to a CLAUDE.md file. Next time you message it, that context is right there in the system prompt.\\n\\nTwo scopes:\\n\\n- Global memory: `data/groups/CLAUDE.md`\\n- Per-chat memory: `data/groups/{chat_id}/CLAUDE.md`\\n\\n### The scheduler\\n\\nThe scheduler is a background Tokio task that wakes up every 60 seconds and checks for due tasks. When it finds one:\\n\\n1. It calls the same `process_with_claude` function that handles regular messages, but with the task\'s prompt as an override.\\n2. The agent runs its full tool loop -- a scheduled task can use web search, bash, file operations, anything.\\n3. The result is sent to the originating chat.\\n4. For cron tasks, the next run time is computed from the cron expression. For one-shot tasks, the status is set to \\"completed\\".\\n\\n### Group chat catch-up\\n\\nIn groups, the bot only responds when @mentioned. But it stores every message. When mentioned, it loads all messages since its last reply in that group.\\n\\nThis means if 50 messages flew by in a group discussion and someone tags the bot asking \\"summarize what just happened\\", the bot sees all 50 messages, not just the most recent ones.\\n\\n## Setup\\n\\nGetting started takes about two minutes:\\n\\n```sh\\ngit clone https://github.com/microclaw/microclaw.git\\ncd microclaw\\ncp .env.example .env\\n```\\n\\nEdit `.env` with three required values:\\n\\n- `TELEGRAM_BOT_TOKEN` -- get one from @BotFather\\n- `ANTHROPIC_API_KEY` -- from console.anthropic.com\\n- `BOT_USERNAME` -- your bot\'s username (without the @)\\n\\nThen:\\n\\n```sh\\ncargo run -- start\\n```\\n\\nOr build a release binary:\\n\\n```sh\\ncargo build --release\\n./target/release/microclaw start\\n```\\n\\nThe binary is self-contained. No database server to install (SQLite is bundled), no external dependencies to configure. It creates its `data/` directory on first run, starts the scheduler automatically, and begins listening for messages.\\n\\n## What\'s different from the original nanoclaw\\n\\nMicroClaw started as a port but has grown beyond feature parity:\\n\\n| Feature | nanoclaw (TS/WhatsApp) | MicroClaw (Rust/Telegram) |\\n|---------|----------------------|--------------------------|\\n| Platform | WhatsApp | Telegram |\\n| Language | TypeScript | Rust |\\n| Deployment | Node.js runtime | Single binary |\\n| Tools | Similar core set | 16 tools (8 original + 8 new) |\\n| Web search | -- | DuckDuckGo search + URL fetch |\\n| Scheduling | Cron reminders | Full agentic scheduled tasks |\\n| Mid-message sending | -- | send_message tool |\\n| Group catch-up | -- | Loads all messages since last reply |\\n| Typing indicator | Single flash | Continuous (every 4s) |\\n\\n## Limitations\\n\\n- No image/voice/document support (text messages only)\\n- No streaming (responses arrive all at once)\\n- No permission model (lock down the host machine)\\n- Single-threaded tool execution per turn\\n- Scheduler granularity (60-second polling)\\n\\n## Final thoughts\\n\\nThe interesting thing about building MicroClaw wasn\'t the Rust or the Telegram integration -- those are just plumbing. The interesting thing is how little code it takes to go from a chatbot that echoes API responses to an agent that can actually do things.\\n\\nThe difference is one loop and a tool registry. Everything else -- the database, the memory system, the scheduler, the message handling -- is supporting infrastructure.\\n\\nSwap Telegram for Slack, Discord, or a web UI. Swap the tools for whatever your domain needs. The core loop stays the same: receive message, call LLM with tools, execute tools in a loop, return response."},{"id":"/release-notes-2026-02","metadata":{"permalink":"/blog/release-notes-2026-02","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-07-release-notes.md","source":"@site/blog/2026-02-07-release-notes.md","title":"MicroClaw Release Notes \u2014 February 2026","description":"This release focuses on documentation clarity and onboarding. The new site consolidates README, developer guide, and testing references into a single navigable docs experience.","date":"2026-02-07T00:00:00.000Z","tags":[{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":false,"label":"Telegram","permalink":"/blog/tags/telegram"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"}],"readingTime":0.43,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/release-notes-2026-02","title":"MicroClaw Release Notes \u2014 February 2026","authors":["microclaw"],"tags":["rust","telegram","agents"]},"unlisted":false,"prevItem":{"title":"Building MicroClaw: An Agentic AI Assistant in Rust That Lives in Your Telegram Chats","permalink":"/blog/building-microclaw"}},"content":"This release focuses on documentation clarity and onboarding. The new site consolidates README, developer guide, and testing references into a single navigable docs experience.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Highlights\\n\\n- Full documentation suite for setup, configuration, and architecture\\n- Dedicated sections for tools, memory, scheduler, and testing\\n- Refined home page to match the MicroClaw visual identity\\n- Setup wizard now documented with visible provider/model list pickers\\n- Provider docs expanded to cover 20+ presets and `custom` mode\\n\\n## Next\\n\\nThe next milestone is a permission model for tool execution and better sandboxing defaults."}]}}')}}]);