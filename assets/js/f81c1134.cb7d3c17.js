"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8130],{7735(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/building-microclaw","metadata":{"permalink":"/blog/building-microclaw","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-07-building-microclaw.md","source":"@site/blog/2026-02-07-building-microclaw.md","title":"Introducing MicroClaw: An Agentic AI Assistant for Telegram","description":"MicroClaw is a Rust-based AI assistant that lives directly in your Telegram chats. Instead of only answering text prompts, it can use tools to complete multi-step tasks: run shell commands, read and edit files, search code, browse the web, schedule jobs, and keep persistent memory.","date":"2026-02-07T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture"},{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":true,"label":"telegram","permalink":"/blog/tags/telegram"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"}],"readingTime":1.72,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/building-microclaw","title":"Introducing MicroClaw: An Agentic AI Assistant for Telegram","authors":["microclaw"],"tags":["architecture","rust","telegram","agents"]},"unlisted":false},"content":"MicroClaw is a Rust-based AI assistant that lives directly in your Telegram chats. Instead of only answering text prompts, it can use tools to complete multi-step tasks: run shell commands, read and edit files, search code, browse the web, schedule jobs, and keep persistent memory.\\n\\nThis post is a short project introduction: what MicroClaw is, how it works, and why the architecture is built this way.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What problem it solves\\n\\nMost chat bots are single-turn wrappers around an LLM API: send user text in, send model text out.\\n\\nMicroClaw uses an agent loop. For each user message, the model can:\\n\\n1. Decide whether to answer directly or call a tool\\n2. Execute one or more tools\\n3. Read tool results\\n4. Continue iterating until the task is complete\\n\\nThat loop turns chat from Q&A into execution.\\n\\n## Core capabilities\\n\\n- Tool execution in chat (`bash`, file ops, `glob`, `grep`, web tools)\\n- Session resume with full tool-call context persisted in SQLite\\n- Context compaction when sessions grow large\\n- Persistent memory via global and per-chat `CLAUDE.md`\\n- Scheduled tasks (one-shot and cron)\\n- Sub-agent execution with a restricted tool set\\n\\n## High-level architecture\\n\\nAt a high level, each message flows through the same pipeline:\\n\\n1. Store message in SQLite\\n2. Load session/history + memory\\n3. Call LLM with tool definitions\\n4. If tool use is requested, execute tool and loop\\n5. When LLM ends turn, return response to chat\\n\\nThe same agent loop is reused by the scheduler, so scheduled jobs can also use tools and reasoning.\\n\\n## Why Rust\\n\\nMicroClaw is written in Rust for operational simplicity and reliability:\\n\\n- Single binary deployment (`cargo build --release`)\\n- Strong typing for message blocks (`text`, `tool_use`, `tool_result`)\\n- Clear shared-state boundaries (`Arc<Database>`)\\n- Predictable async runtime behavior with Tokio\\n\\n## Project status\\n\\nMicroClaw is under active development. Current focus areas are improving onboarding, hardening runtime safety defaults, and making multi-chat operations more robust.\\n\\nIf you want to explore the full docs, start here:\\n\\n- https://microclaw.ai/docs/overview\\n- https://microclaw.ai/docs/architecture\\n- https://microclaw.ai/docs/tools"}]}}')}}]);