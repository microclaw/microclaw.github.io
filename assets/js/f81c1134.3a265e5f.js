"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8130],{7735(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/microclaw-vs-nanoclaw-openclaw","metadata":{"permalink":"/blog/microclaw-vs-nanoclaw-openclaw","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-08-microclaw-vs-nanoclaw-openclaw-medium.md","source":"@site/blog/2026-02-08-microclaw-vs-nanoclaw-openclaw-medium.md","title":"MicroClaw vs NanoClaw vs OpenClaw: Three Paths from Minimalism to Platform","description":"If you are building a personal AI assistant that lives inside chat apps, you usually end up on one of three paths:","date":"2026-02-08T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture"},{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":false,"label":"Telegram","permalink":"/blog/tags/telegram"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"},{"inline":false,"label":"Comparison","permalink":"/blog/tags/comparison"}],"readingTime":4.47,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/microclaw-vs-nanoclaw-openclaw","title":"MicroClaw vs NanoClaw vs OpenClaw: Three Paths from Minimalism to Platform","authors":["microclaw"],"tags":["architecture","rust","telegram","agents","comparison"]},"unlisted":false,"nextItem":{"title":"MicroClaw vs NanoClaw: A Practical Comparison","permalink":"/blog/microclaw-vs-nanoclaw"}},"content":"If you are building a personal AI assistant that lives inside chat apps, you usually end up on one of three paths:\\n\\n1. Minimal and understandable, with isolation first\\n2. Feature-rich and multi-platform, with ecosystem breadth first\\n3. A middle path with practical built-ins and controlled complexity\\n\\nMicroClaw, NanoClaw, and OpenClaw each sit at different points on that spectrum.\\n\\nThis post compares the three from an engineering perspective, based on publicly available repositories and docs as of February 8, 2026.\\n\\n\x3c!-- truncate --\x3e\\n\\n## TL;DR\\n\\n- If your top priority is minimal code and container isolation, NanoClaw is a strong fit.\\n- If you want a full personal AI platform (many channels, nodes, voice, canvas, control plane), OpenClaw is stronger.\\n- If you want a Telegram-first assistant that is practical, maintainable, and feature-complete for daily use, MicroClaw is the more balanced choice.\\n\\n## At a Glance (Engineering View)\\n\\n| Dimension | NanoClaw | OpenClaw | MicroClaw |\\n|---|---|---|---|\\n| Product orientation | Single-user, minimal, highly understandable | Personal AI platform (control plane + multi-surface ecosystem) | Practical chat agent, Telegram-first |\\n| Primary stack | Node.js + Claude Agent SDK | TypeScript/Node.js platform architecture | Rust + Tokio + teloxide |\\n| Default channel | WhatsApp-first | Multi-channel (WA/Telegram/Slack/Discord/...) | Telegram-first (optional WhatsApp webhook, Discord) |\\n| Model strategy | Closely coupled to Claude Code/Agent SDK workflow | Multi-provider strategy with failover concepts | Native Anthropic + OpenAI-compatible abstraction |\\n| Tool execution | Containerized execution as core principle | Broad tool ecosystem (browser/canvas/nodes/cron, etc.) | Built-in tool registry + sub-agent + skills + todo |\\n| Session model | README emphasizes simplicity/isolation | Platform-level session/gateway/WS control plane | Full session persistence (including `tool_use` / `tool_result`) |\\n| Context management | More skill-driven extension approach | Built-in pruning/session management capabilities | Built-in context compaction for long sessions |\\n| Security emphasis | OS-level isolation (Apple Container/Docker) | Gateway policy + pairing/allowlist + platform controls | App-level auth + chat-level access control + hardening path |\\n| Deployment shape | Claude-driven setup + container dependency | CLI + daemon + companion app/node | Rust single-binary deployment |\\n| Best fit | Builders who want full control of a minimal core | Users who want a maximal capability platform | Developers who want practical features with maintainable complexity |\\n\\n## Why MicroClaw Is Not \u201cAnother OpenClaw\u201d\\n\\nOpenClaw has gone very deep on the \u201cpersonal AI platform\u201d direction: multi-channel support, gateway control plane, nodes, voice, canvas, web surfaces, remote access, and skill ecosystem.\\n\\nThat is not inherently good or bad. It is a complexity budget decision.\\n\\nMicroClaw makes different tradeoffs:\\n\\n- It does not try to cover every surface at once; it optimizes the Telegram path first.\\n- It does not build a heavy control plane first; it prioritizes a robust agent loop, tool execution, session recovery, scheduling, and memory.\\n- It uses Rust and a straightforward process model to reduce hidden runtime state.\\n\\nSo it is not copying OpenClaw. It is optimizing for a different complexity tier.\\n\\n## Why MicroClaw Is Not \u201cNanoClaw in Rust\u201d\\n\\nNanoClaw\u2019s value proposition is clear: keep the core tiny, understandable, and isolation-first, then customize through skills instead of bloating the base.\\n\\nMicroClaw shares the \u201cpersonal assistant should be controllable\u201d philosophy, but applies it differently:\\n\\n- NanoClaw emphasizes minimizing infrastructure.\\n- MicroClaw emphasizes practical built-ins for daily use, including:\\n  - Full session resume with tool interaction context\\n  - Built-in context compaction\\n  - Sub-agents with restricted tool sets\\n  - Planning/todo tools\\n  - On-demand skill activation\\n\\nIn short: NanoClaw pushes minimal core purity; MicroClaw adds one practical layer above that core.\\n\\n## The Core Difference: Where You Place Complexity\\n\\nIn personal AI assistants, complexity does not disappear. You choose where it lives.\\n\\n- NanoClaw puts complexity into your fork-level customization workflow.\\n- OpenClaw puts complexity into platform breadth and ecosystem depth.\\n- MicroClaw puts complexity into built-in high-frequency features while keeping the architecture traceable.\\n\\nThat is why all three can succeed and coexist.\\n\\n## Selection Guide by Real Use Case\\n\\n### Choose NanoClaw if:\\n\\n- You strongly prioritize container isolation boundaries.\\n- You are comfortable adding capabilities via skills and fork-level changes.\\n- You want to understand the core code path quickly.\\n\\n### Choose OpenClaw if:\\n\\n- You need unified access across many channels and device nodes.\\n- You care about voice, canvas, remote gateway, and platform-grade automation.\\n- You are willing to pay higher ops/config complexity for a higher feature ceiling.\\n\\n### Choose MicroClaw if:\\n\\n- Telegram is your primary interface and you want fast time-to-value.\\n- You need tool execution + automation, but also robust session recovery and context management.\\n- You want a better balance between capability and maintainability.\\n\\n## What MicroClaw Should Do Next\\n\\nBased on this comparison, the next high-leverage steps for MicroClaw are not random feature additions:\\n\\n1. Strengthen default safety boundaries for high-risk tools\\n2. Improve behavior consistency across channels (Telegram/WhatsApp/Discord)\\n3. Clarify skill/tool boundaries to reduce prompt overhead and misuse\\n4. Improve observability for scheduler/session/tool failures\\n\\nThe goal is not to become OpenClaw. The goal is to make the \u201cmid-complexity, high-utility assistant\u201d category more reliable.\\n\\n## Final Take\\n\\nThis is not a \u201cwhich one is best\u201d debate. It is a \u201cwhat kind of assistant do you want to operate\u201d decision.\\n\\n- If you want a controllable scalpel: NanoClaw  \\n- If you want a powerful workstation platform: OpenClaw  \\n- If you want a dependable daily engineering vehicle: MicroClaw\\n\\nChoosing the right path matters more than chasing feature trends.\\n\\n## References\\n\\n- NanoClaw: https://github.com/gavrielc/nanoclaw\\n- NanoClaw README: https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md\\n- OpenClaw: https://github.com/openclaw/openclaw\\n- OpenClaw Docs: https://docs.openclaw.ai\\n- MicroClaw: https://github.com/microclaw/microclaw"},{"id":"/microclaw-vs-nanoclaw","metadata":{"permalink":"/blog/microclaw-vs-nanoclaw","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-08-microclaw-vs-nanoclaw.md","source":"@site/blog/2026-02-08-microclaw-vs-nanoclaw.md","title":"MicroClaw vs NanoClaw: A Practical Comparison","description":"MicroClaw was inspired by NanoClaw. They share the same core idea: an AI assistant that can execute tools from chat.","date":"2026-02-08T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture"},{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":false,"label":"Chat","permalink":"/blog/tags/chat"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"}],"readingTime":2.52,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/microclaw-vs-nanoclaw","title":"MicroClaw vs NanoClaw: A Practical Comparison","authors":["microclaw"],"tags":["architecture","rust","chat","agents"]},"unlisted":false,"prevItem":{"title":"MicroClaw vs NanoClaw vs OpenClaw: Three Paths from Minimalism to Platform","permalink":"/blog/microclaw-vs-nanoclaw-openclaw"},"nextItem":{"title":"Building MicroClaw: A Practical Agentic Assistant for Telegram","permalink":"/blog/building-microclaw"}},"content":"MicroClaw was inspired by [NanoClaw](https://github.com/gavrielc/nanoclaw/). They share the same core idea: an AI assistant that can execute tools from chat.\\n\\nThis post compares the two projects from an engineering and product perspective, based on current public documentation.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Scope note\\n\\nThe NanoClaw side of this comparison is based on its official README as of February 8, 2026. If NanoClaw changes later, some rows may evolve.\\n\\n## Comparison table\\n\\n| Dimension | NanoClaw | MicroClaw |\\n|---|---|---|\\n| Project orientation | Minimal, single-user, \\"small enough to understand\\" | Broader chat-agent feature set for practical daily use |\\n| Relationship | Original project | Inspired by NanoClaw and expanded for Rust + Telegram workflows |\\n| Default channel | WhatsApp-first | Telegram-first (with optional WhatsApp Cloud webhook support) |\\n| Multi-channel philosophy | Prefer transformation skills (for example `/add-telegram`) over built-in multi-channel complexity | Built as a chat-surface bot with Telegram as primary experience |\\n| Primary stack | Node.js + Claude Agent SDK + container runtime | Rust + Tokio + teloxide + reqwest |\\n| Model/provider strategy | Tied to Claude Code / Agent SDK workflow | Native Anthropic + OpenAI-compatible provider abstraction |\\n| Tool system | README describes major capabilities (web, scheduling, etc.) | Explicit tool registry with file, shell, web, memory, scheduler, export, sub-agent, todo, and skills tools |\\n| Agent execution loop | Agent runs through containerized Claude workflow | Explicit `tool_use` / `tool_result` loop with iteration cap |\\n| Security posture emphasis | OS-level isolation via Apple Container/Docker sandboxes | In-app tool authorization + deployment hardening strategies |\\n| Host access model | Commands run inside container with mounted scope | Commands/tools run in runtime environment; boundaries enforced by auth and ops controls |\\n| Persistence | SQLite | SQLite (messages, chats, sessions, scheduled tasks, etc.) |\\n| Session continuity | Persistent behavior implied; less emphasis on tool-block replay details in README | Full session resume including tool interaction context |\\n| Context compaction | Mentioned as a skill direction (`/add-clear`) | Built-in context compaction for oversized sessions |\\n| Memory structure | Per-group `CLAUDE.md` with isolation focus | Global + per-chat `AGENTS.md` scopes |\\n| Scheduler | Recurring task support | One-shot + cron recurring tasks with management tools |\\n| Sub-agent capability | Not explicitly documented in README | Built-in `sub_agent` with restricted tool set |\\n| Planning/todo tools | Not explicitly documented in README | Built-in todo read/write tools |\\n| Extensibility model | \\"Skills over features\\" is a core principle | Supports skill activation while also shipping broader built-in capabilities |\\n| Configuration philosophy | Fewer knobs; customize by code changes | Config-driven runtime with provider/model/authorization options |\\n| Deployment shape | Claude Code-centric + container requirements | Single-binary Rust deployment path (`cargo build --release`) |\\n| Best fit | Users who want container-isolated, minimal, deeply personalized forks | Users who want rich Telegram-native agent workflows with built-in operational features |\\n\\n## Bottom line\\n\\nNanoClaw optimizes for minimalism and container isolation first.\\n\\nMicroClaw optimizes for built-in capability breadth and Telegram-first agent workflows.\\n\\nBoth are valid choices. The right one depends on whether your top priority is minimal isolated substrate (NanoClaw) or broader integrated functionality out of the box (MicroClaw).\\n\\n## References\\n\\n- NanoClaw repository: https://github.com/gavrielc/nanoclaw/\\n- NanoClaw README (raw): https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md\\n- MicroClaw repository: https://github.com/microclaw/microclaw\\n- MicroClaw docs: https://microclaw.ai/docs/overview"},{"id":"/building-microclaw","metadata":{"permalink":"/blog/building-microclaw","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-07-building-microclaw.md","source":"@site/blog/2026-02-07-building-microclaw.md","title":"Building MicroClaw: A Practical Agentic Assistant for Telegram","description":"MicroClaw is a Rust-based AI assistant that lives directly in your chats. It is built for one specific goal: turn chat into a reliable execution surface, not just a text interface.","date":"2026-02-07T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture"},{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":false,"label":"Telegram","permalink":"/blog/tags/telegram"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"}],"readingTime":4.62,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/building-microclaw","title":"Building MicroClaw: A Practical Agentic Assistant for Telegram","authors":["microclaw"],"tags":["architecture","rust","telegram","agents"]},"unlisted":false,"prevItem":{"title":"MicroClaw vs NanoClaw: A Practical Comparison","permalink":"/blog/microclaw-vs-nanoclaw"}},"content":"MicroClaw is a Rust-based AI assistant that lives directly in your chats. It is built for one specific goal: turn chat into a reliable execution surface, not just a text interface.\\n\\nMicroClaw can run shell commands, read and edit files, search code, browse the web, schedule recurring tasks, and maintain persistent memory. It is Telegram-first today, with optional WhatsApp and Discord paths, and it is designed to stay understandable as it grows.\\n\\nThis post is a full introduction to the project: where the idea came from, what design decisions shaped it, and how the architecture works in practice.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Where the Idea Came From\\n\\nMicroClaw was inspired by two things happening at the same time:\\n\\n1. The rise of **NanoClaw**, which proved that personal AI assistants should be understandable, self-hostable, and opinionated.\\n2. The release wave around **Claude Opus 4.6**, which made long-context, tool-heavy assistant workflows feel much more practical for real daily use.\\n\\nNanoClaw showed that small and focused systems can be powerful. Opus 4.6 showed that model capability had reached a point where multi-step reasoning with tools could be trustworthy enough to build on.\\n\\nMicroClaw started as a question:  \\nCan we keep the spirit of NanoClaw, but build a Telegram-first assistant in Rust with stronger session continuity, operational stability, and practical built-ins?\\n\\nThe answer became this project.\\n\\n## The Problem MicroClaw Solves\\n\\nMost chat bots are still single-turn wrappers:\\n\\n- user sends text\\n- model returns text\\n- conversation state is shallow\\n- no durable execution context\\n\\nThat is fine for Q&A, but weak for real work.\\n\\nMicroClaw treats each message as an **agentic task loop**. For each incoming message, the model can:\\n\\n1. Decide whether to answer directly or use tools\\n2. Execute one or more tools\\n3. Read tool outputs\\n4. Keep iterating until the task is done\\n5. Persist the state for the next turn\\n\\nThis turns chat from \u201cask and answer\u201d into \u201cplan, execute, and continue.\u201d\\n\\n## What Makes MicroClaw Different\\n\\nMicroClaw is designed around four practical requirements.\\n\\n### 1) Durable conversations, not stateless prompts\\n\\nSessions are persisted in SQLite with full tool context (`tool_use` and `tool_result` blocks).  \\nWhen a new message arrives, the assistant can resume from real prior execution state, not just a truncated chat summary.\\n\\n### 2) Memory that can evolve over time\\n\\nMicroClaw supports global and per-chat `AGENTS.md` memory.\\nThe assistant can read and update memory through tools, so preferences and project context survive across days or weeks.\\n\\n### 3) Operational features built in\\n\\nIt includes production-relevant features out of the box:\\n\\n- context compaction for oversized sessions\\n- scheduled one-shot and recurring tasks\\n- continuous typing indicator during long tool loops\\n- group catch-up behavior for mention-based activation\\n- message splitting for platform limits\\n\\n### 4) Controlled delegation\\n\\nMicroClaw includes a `sub_agent` tool that launches a restricted inner agent with a reduced tool set.  \\nThis allows decomposition of complex work while keeping clear safety boundaries.\\n\\n## Core Capabilities\\n\\n- Chat-native tool execution (`bash`, file operations, `glob`, `grep`, web search/fetch)\\n- Persistent session resume including tool interaction history\\n- Context compaction for long-running sessions\\n- Global + per-chat persistent memory via `AGENTS.md`\\n- Scheduler for cron and one-time tasks\\n- Skill activation for domain-specific instructions\\n- Todo/plan tools for structured multi-step execution\\n- Optional cross-surface integrations (Telegram-first, plus optional WhatsApp/Discord)\\n\\n## High-level architecture\\n\\nAt a high level, every message follows the same execution path:\\n\\n1. Store message in SQLite\\n2. Load session state, recent history, and memory\\n3. Call LLM with tool definitions\\n4. If `tool_use` is requested, execute tool(s) and loop\\n5. If `end_turn`, send response and persist updated session\\n\\nThe scheduler reuses this same loop.  \\nThat means scheduled tasks are not \u201cdumb reminders\u201d but full agent invocations with tools, reasoning, and memory access.\\n\\n## Why Rust\\n\\nMicroClaw is written in Rust for reliability and operational clarity:\\n\\n- Single binary deployment (`cargo build --release`)\\n- Strong typing for protocol/message block structures\\n- Explicit shared-state boundaries (`Arc<Database>`)\\n- Predictable async behavior via Tokio\\n- Lower accidental complexity in long-running bot processes\\n\\nRust is not used for novelty. It is used because this project is a long-lived process that handles concurrency, persistence, and external APIs continuously.\\n\\n## Design Principles\\n\\nMicroClaw follows a few strict rules:\\n\\n- **Execution-first**: a useful assistant must do work, not only generate text.\\n- **State is a feature**: preserving session and memory quality is as important as model quality.\\n- **Simple core, practical edges**: keep architecture small, but include features needed in real daily workflows.\\n- **Safety by layers**: combine tool-level checks, chat access controls, and deployment hardening.\\n- **Composable growth**: add capabilities via tools and skills without breaking the core loop.\\n\\n## Example Workflows\\n\\nHere are the kinds of tasks MicroClaw is designed for:\\n\\n- \u201cSearch this repo for API breaking changes and draft release notes.\u201d\\n- \u201cEvery weekday at 9am, send me an AI news briefing from selected sources.\u201d\\n- \u201cRead this error log, find likely root causes, and propose fixes.\u201d\\n- \u201cRemember that I prefer concise responses and Rust code examples.\u201d\\n- \u201cBreak this migration into a todo plan and execute step by step.\u201d\\n\\nThese are not one-shot prompts. They are iterative workflows with context and state.\\n\\n## Project status\\n\\nMicroClaw is under active development. Current priorities are:\\n\\n1. Stronger default safety boundaries for tool execution\\n2. Better multi-channel consistency across Telegram/WhatsApp/Discord\\n3. Better observability for scheduler/session/tool failures\\n4. Smoother onboarding and configuration UX\\n\\nIf you want to explore the full docs, start here:\\n\\n- https://microclaw.ai/docs/overview\\n- https://microclaw.ai/docs/architecture\\n- https://microclaw.ai/docs/tools\\n- Source code: https://github.com/microclaw/microclaw"}]}}')}}]);