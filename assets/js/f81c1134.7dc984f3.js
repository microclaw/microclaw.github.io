"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8130],{7735(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/microclaw-february-2026-updates","metadata":{"permalink":"/blog/microclaw-february-2026-updates","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-19-microclaw-february-updates.md","source":"@site/blog/2026-02-19-microclaw-february-updates.md","title":"MicroClaw Feb 19: What Changed in the Past Week","description":"MicroClaw has moved quickly in February, with significant updates across ClawHub integration, voice handling, path compatibility, modularization, web/auth hardening, and release automation.","date":"2026-02-19T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"},{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":false,"label":"Chat","permalink":"/blog/tags/chat"}],"readingTime":4.71,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/microclaw-february-2026-updates","title":"MicroClaw Feb 19: What Changed in the Past Week","authors":["microclaw"],"tags":["architecture","agents","rust","chat"]},"unlisted":false,"nextItem":{"title":"Built with Rust: MicroClaw as a Multi-Channel Agent Runtime","permalink":"/blog/built-with-rust-microclaw-runtime"}},"content":"MicroClaw has moved quickly in February, with significant updates across ClawHub integration, voice handling, path compatibility, modularization, web/auth hardening, and release automation.\\n\\nThis post summarizes the direction and outcomes based on the **50 most recent commits** on `main`.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Scope and Time Window\\n\\nThis update covers the most recent 50 commits up to **February 19, 2026**.\\n\\nAt a high level, the work clusters into six tracks:\\n\\n- ClawHub and skills lifecycle\\n- provider/runtime compatibility\\n- config/path compatibility and migration safety\\n- web/auth/ops hardening\\n- modular crate boundaries and codebase cleanup\\n- release and deployment reliability\\n\\n## 1) ClawHub: From Initial Integration to Production-Friendly Flow\\n\\nThe registry path is now substantially more practical.\\n\\nKey outcomes from this cycle:\\n\\n- `microclaw skill` command set is usable for search/install/list/inspect workflows\\n- async runtime panic scenarios were removed in CLI/tool execution paths\\n- transient failures now have retry behavior in key flows\\n- `/reload-skills` support was added in multiple channels to reduce restart dependency\\n- follow-up fixes corrected install result semantics and endpoint behavior\\n\\nOperationally, this means less friction for skill discovery and activation, and fewer false-positive install states.\\n\\n## 2) Voice Transcription: Cloud + Local Execution Modes\\n\\nVoice handling now supports both hosted and local execution paths.\\n\\nHighlights:\\n\\n- OpenAI remains the default provider path\\n- local command-based transcription is now configurable\\n- failure-path cleanup was tightened to avoid temp-file leaks\\n\\nThis gives teams more flexibility in privacy/performance/cost tradeoffs while preserving a simple default for most users.\\n\\n## 3) Path and Data Compatibility: Hardening After Real-World Merge Pressure\\n\\nA major focus in the follow-up work was preventing path regressions.\\n\\nImportant corrections included:\\n\\n- restoring dynamic `data_dir` behavior for skills/lockfile defaults\\n- aligning assertions and cross-platform path expectations\\n- clarifying skills source layout (`skills/built-in`) vs runtime state layout\\n\\nNet effect: upgrades are safer for existing deployments that already depend on custom data roots.\\n\\n## 4) Runtime and Provider Compatibility\\n\\nThe runtime also received compatibility-focused cleanup:\\n\\n- DeepSeek/tool-call behavior fixes\\n- replacement of brittle model-name checks with provider capability flags\\n- improved LLM/provider conventions in docs to reduce future drift\\n\\nThis lowers maintenance risk as provider APIs evolve.\\n\\n## 5) Web/Auth/Ops and Modularity Progress\\n\\nBeyond feature work, a lot of value in this batch is structural:\\n\\n- auth/metrics and config self-check hardening\\n- web handler refactors and module split cleanup\\n- continued modular extraction into workspace crates (`core/storage/tools/channels/app`)\\n- removal of temporary wrappers/shims after migration milestones\\n\\nThese changes improve long-term maintainability and make feature iteration less risky.\\n\\n## 6) Release and Delivery Cadence\\n\\nThis period also included active release execution work:\\n\\n- version bumps through `0.0.83`, `0.0.85`, `0.0.86`\\n- release/build script refinements\\n- Homebrew tap updates and release packaging flow maintenance\\n\\nThe direction is clear: keep shipping while steadily tightening quality gates and deployment repeatability.\\n\\n## What to Expect Next\\n\\nGiven this trajectory, near-term priorities are likely to continue around:\\n\\n- ClawHub reliability and skill lifecycle UX\\n- cross-channel consistency in runtime behavior\\n- deployment smoothness and fewer manual release interventions\\n- further simplification after modularization milestones\\n\\n---\\n\\n## Appendix: 50 Recent Commits Covered\\n\\n- `1a67c37` chore: trigger CI for release 0.0.86 finalize\\n- `4b8f7b1` bump version to 0.0.86\\n- `d6a030e` Merge pull request #45 from microclaw/fix/pr44-followup\\n- `7d2aba1` fix ignore\\n- `30e00f4` mv skill dir\\n- `94dcfe9` docs: regenerate config defaults artifact\\n- `8c30d3d` fix: follow up PR44 path and clawhub install regressions\\n- `0ab79bc` Merge pull request #44 from klampatech/feature/clawhub-integration-fixes\\n- `45e1ddf` chore: remove test artifacts from PR\\n- `039c11f` bump version to 0.0.85\\n- `60fb947` docs: add llm provider capability-based conventions\\n- `c09a3bc` Merge origin/main into feature branch and resolve conflicts\\n- `10ae7b6` refactor(llm): replace DeepSeek model-name checks with provider capability flags\\n- `a933732` Merge pull request #43 from mission-deny-the-mission/fix/deepseek-reasoning\\n- `bf4fb7e` feat(clawhub): integrate ClawHub skills and add local voice transcription\\n- `d49b1a3` Merge pull request #42 from microclaw/feature/ops-hardening-feb19\\n- `40516fd` Fix windows path assertions and document path compatibility\\n- `98e67c9` Improve skill availability diagnostics and filtering\\n- `3606842` Move built-in skill sources to skills/built-in\\n- `9715f8a` Update working_dir default to home-based path\\n- `5597f39` Simplify data/skills path logic without env overrides\\n- `5068792` fix deepseek reasoning/tool-call compatibility\\n- `65567cd` Default data_dir to ~/.microclaw when not configured\\n- `82351af` Add configurable skills_dir override\\n- `216dac9` Harden web metrics/auth flow and adopt ~/.microclaw skills home\\n- `7456f0c` Merge pull request #41 from microclaw/codex/fix-clawhub-pr39\\n- `7053399` refactor clawhub config, test templates, and gateway adapter\\n- `bf6d7b7` extract clawhub core into microclaw-clawhub crate\\n- `d85f226` update generated config defaults and include clawhub fixes\\n- `5852ffa` fix clawhub merge fallout and restore lint clean\\n- `3d95bec` Merge pull request #39 from klampatech/feat/clawhub-integration\\n- `e58a244` Merge branch \'feature/clawhub-init-v0\' into feat/clawhub-integration\\n- `432e2aa` bump version to 0.0.83\\n- `6185b81` Merge pull request #40 from microclaw/feature/auth-feature\\n- `d80571e` Fix legacy sessions schema index init ordering\\n- `5fd4314` Add merge notes and rollback steps to upgrade guide\\n- `4f278a8` Use platform hook scripts in hook block test\\n- `c8a3a8e` Fix Windows hook block test command quoting\\n- `450c77c` Add config self-check UI and split web config/stream modules\\n- `b2df265` Refactor web handlers and harden config/OTLP checks\\n- `1215d2a` lots of features\\n- `f5ca180` bump version to 0.0.82\\n- `faa2ad6` chore: trigger CI on main\\n- `8e11fba` feat(clawhub): complete ClawHub integration v1\\n- `3d59af4` bump version to 0.0.81\\n- `4083f56` docs: align architecture and runtime docs with crate layout\\n- `e33288f` Merge pull request #38 from microclaw/pr/final-cleanup-remove-usage-wrapper\\n- `eb96f48` refactor(storage): remove usage wrapper module and use storage usage API directly\\n- `e07bf93` Merge pull request #37 from microclaw/pr/finalize-modularity-boundaries\\n- `5780822` refactor(modularity): finalize crate imports and remove legacy shim modules"},{"id":"/built-with-rust-microclaw-runtime","metadata":{"permalink":"/blog/built-with-rust-microclaw-runtime","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-14-built-with-rust-microclaw-runtime.md","source":"@site/blog/2026-02-14-built-with-rust-microclaw-runtime.md","title":"Built with Rust: MicroClaw as a Multi-Channel Agent Runtime","description":"MicroClaw is no longer just a channel bot. In its current form, it is a Rust multi-channel agent runtime with a shared agent engine, provider abstraction, durable session state, and layered memory.","date":"2026-02-14T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture"},{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"},{"inline":false,"label":"Telegram","permalink":"/blog/tags/telegram"}],"readingTime":4.22,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/built-with-rust-microclaw-runtime","title":"Built with Rust: MicroClaw as a Multi-Channel Agent Runtime","authors":["microclaw"],"tags":["architecture","rust","agents","telegram"]},"unlisted":false,"prevItem":{"title":"MicroClaw Feb 19: What Changed in the Past Week","permalink":"/blog/microclaw-february-2026-updates"},"nextItem":{"title":"MicroClaw vs NanoClaw vs OpenClaw: Updated Three-Path Comparison","permalink":"/blog/microclaw-vs-nanoclaw-openclaw"}},"content":"MicroClaw is no longer just a channel bot. In its current form, it is a **Rust multi-channel agent runtime** with a shared agent engine, provider abstraction, durable session state, and layered memory.\\n\\nIt supports Telegram, Discord, and Web through adapters, while keeping one core execution path for reasoning and tool use.\\n\\nSource code: https://github.com/microclaw/microclaw\\nQuick Start: https://microclaw.ai/docs/quickstart\\n\\n![MicroClaw system architecture](/img/blog/microclaw-runtime/01-system-architecture.svg)\\n\\n\x3c!-- truncate --\x3e\\n\\n## What MicroClaw Is Today\\n\\nAt a high level, MicroClaw combines:\\n\\n- A single channel-agnostic agent loop (`src/agent_engine.rs`)\\n- A provider-agnostic LLM layer (`src/llm.rs`) with native Anthropic plus OpenAI-compatible providers\\n- Multi-step tool execution with schema-driven tool definitions\\n- Session resume + context compaction for long-running conversations\\n- Two memory layers: file memory and structured SQLite memory\\n- Background scheduling plus memory reflection jobs\\n- Usage and memory observability APIs for operational visibility\\n\\nThis architecture keeps product behavior consistent across channels while allowing independent evolution of adapters and providers.\\n\\n## Why Built with Rust\\n\\nRust is a strong fit for this runtime shape:\\n\\n- Tokio handles concurrent chat traffic and background loops with low overhead\\n- Strict types and ownership help keep tool/state boundaries predictable\\n- Shared state (`Arc<...>`) across runtime, tools, scheduler, and channels remains explicit\\n- A single compiled binary keeps deployment and operations straightforward\\n\\n![Rust value map](/img/blog/microclaw-runtime/02-rust-value-map.svg)\\n\\n## Core Runtime Shape\\n\\nThe runtime wiring in `src/runtime.rs` initializes providers, tools, memory services, channels, and background workers into one `AppState`.\\n\\nThe execution split is clean:\\n\\n- **Adapters** (`channels/telegram.rs`, `channels/discord.rs`, `web.rs`) handle ingress/egress\\n- **Engine** (`agent_engine.rs`) runs the shared reasoning/tool loop\\n- **Provider layer** (`llm.rs`) abstracts model APIs and stream handling\\n- **Persistence** (`db.rs`) stores messages, sessions, tasks, memories, and observability\\n\\n![Platform adapters and shared core pipeline](/img/blog/microclaw-runtime/03-platform-core-pipeline.svg)\\n\\n## The Agent Loop\\n\\n`process_with_agent` is the central path:\\n\\n1. Optional explicit-memory fast path (`remember ...` / `\u8bb0\u4f4f...`)\\n2. Restore prior session or reconstruct from history\\n3. Build system prompt from file memory, structured memory, and skills catalog\\n4. Compact old context if limits are exceeded\\n5. Call selected LLM provider with tool schemas\\n6. On `tool_use`, execute tool(s), append results, and continue\\n7. On `end_turn`, persist session and return response\\n\\nThis gives MicroClaw controlled, iterative tool use while preserving resumability.\\n\\n![Agent loop sequence](/img/blog/microclaw-runtime/04-agentic-loop-sequence.svg)\\n\\n## Tool System and Safety\\n\\nThe tool system (`src/tools/mod.rs`) provides a common `Tool` trait and `ToolRegistry` dispatch with auth context injection.\\n\\nKey traits of the current system:\\n\\n- JSON-schema tool definitions consumed by providers\\n- High-risk tool approval gate in sensitive contexts\\n- Built-in tool docs generated from code to prevent doc drift\\n- Sub-agent mode with a restricted registry (`new_sub_agent`)\\n\\n![Main agent vs sub-agent boundary](/img/blog/microclaw-runtime/05-main-vs-sub-agent-boundary.svg)\\n\\n## Memory Is Layered, Not Monolithic\\n\\nMicroClaw now uses two complementary memory layers.\\n\\n### 1) File memory\\n\\n- Global: `runtime/groups/AGENTS.md`\\n- Per chat: `runtime/groups/{chat_id}/AGENTS.md`\\n\\n### 2) Structured memory (`memories` table)\\n\\n- Normalized records with category/confidence/source/last_seen\\n- Archive lifecycle and supersede edges (`memory_supersede_edges`)\\n- Explicit-memory fast path + reflector extraction from conversation history\\n\\nThis layered design keeps user-facing notes simple while enabling queryable memory operations in SQLite.\\n\\n![Memory hierarchy and lifecycle](/img/blog/microclaw-runtime/06-context-lifecycle.svg)\\n\\n![File + structured memory model](/img/blog/microclaw-runtime/07-memory-hierarchy.svg)\\n\\n## Scheduler + Reflector Background Jobs\\n\\nBackground workers in `scheduler.rs` run on intervals:\\n\\n- Execute due scheduled tasks\\n- Trigger memory reflector passes\\n- Persist run metadata for observability\\n\\nSo MicroClaw is not only reactive to incoming messages, but also proactive through timed execution and memory maintenance.\\n\\n![Scheduler and reflector lifecycle](/img/blog/microclaw-runtime/08-scheduled-task-lifecycle.svg)\\n\\n## Cross-Channel Behavior\\n\\nEach channel keeps its own delivery rules, but all share the same engine.\\n\\n- Telegram and Discord apply adapter-specific mention and output limits\\n- Web supports send/stream APIs and replay endpoints\\n- Session/history/reset/delete behavior is unified through shared persistence\\n\\n![Telegram vs Discord handling](/img/blog/microclaw-runtime/09-telegram-vs-discord-handling.svg)\\n\\n## Data Model and Observability\\n\\n`db.rs` now covers more than core chat storage. In addition to `chats/messages/sessions/scheduled_tasks`, it includes:\\n\\n- Structured memory tables (`memories`, `memory_supersede_edges`)\\n- Memory observability tables (`memory_reflector_runs`, `memory_injection_logs`)\\n- Schema versioning and migration tracking (`db_meta`, `schema_migrations`)\\n\\nOperational surfaces include:\\n\\n- `/api/usage`\\n- `/api/memory_observability`\\n- Web Usage panel trend cards\\n\\n![Database and observability schema](/img/blog/microclaw-runtime/10-database-er.svg)\\n\\n## Extending MicroClaw\\n\\nFor new tools and capabilities:\\n\\n1. Implement a new tool under `src/tools/`\\n2. Register it via `ToolRegistry`\\n3. Keep schemas explicit and docs generated from source\\n4. Reuse `process_with_agent` rather than adding platform-specific loops\\n\\nThis keeps the runtime coherent as features scale.\\n\\n![New tool flow](/img/blog/microclaw-runtime/11-new-tool-flow.svg)\\n\\n## Final Take\\n\\nMicroClaw is best understood as a **Rust agent runtime**:\\n\\n- Multi-channel adapters\\n- Provider abstraction\\n- Unified agent loop\\n- Durable sessions\\n- Layered memory with quality + reflection\\n- Production observability\\n\\nThat combination makes it a practical foundation for long-running, tool-using AI assistants.\\n\\n![Built with Rust runtime summary](/img/blog/microclaw-runtime/12-closing-overview.svg)"},{"id":"/microclaw-vs-nanoclaw-openclaw","metadata":{"permalink":"/blog/microclaw-vs-nanoclaw-openclaw","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-08-microclaw-vs-nanoclaw-openclaw-medium.md","source":"@site/blog/2026-02-08-microclaw-vs-nanoclaw-openclaw-medium.md","title":"MicroClaw vs NanoClaw vs OpenClaw: Updated Three-Path Comparison","description":"If you are building a personal AI assistant around chat, you usually choose among three distinct paths:","date":"2026-02-08T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture"},{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":false,"label":"Telegram","permalink":"/blog/tags/telegram"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"},{"inline":false,"label":"Comparison","permalink":"/blog/tags/comparison"}],"readingTime":2.36,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/microclaw-vs-nanoclaw-openclaw","title":"MicroClaw vs NanoClaw vs OpenClaw: Updated Three-Path Comparison","authors":["microclaw"],"tags":["architecture","rust","telegram","agents","comparison"]},"unlisted":false,"prevItem":{"title":"Built with Rust: MicroClaw as a Multi-Channel Agent Runtime","permalink":"/blog/built-with-rust-microclaw-runtime"},"nextItem":{"title":"Building MicroClaw: A Practical Agent Runtime for Telegram and Beyond","permalink":"/blog/building-microclaw"}},"content":"If you are building a personal AI assistant around chat, you usually choose among three distinct paths:\\n\\n1. Minimal and isolation-first\\n2. Broad platform with high feature surface\\n3. Balanced runtime with practical built-ins\\n\\nThis comparison is updated using publicly available docs/repos as of **February 14, 2026**.\\n\\n![Three-path capability spectrum](/img/blog/refresh-2026-02/03-three-paths-spectrum.svg)\\n\\n\x3c!-- truncate --\x3e\\n\\n## TL;DR\\n\\n- **NanoClaw**: best when minimal code surface and container isolation are the top priorities.\\n- **OpenClaw**: best when you need wide channel/platform coverage with control-plane breadth.\\n- **MicroClaw**: best when you want a practical middle path with durable state and maintainable complexity.\\n\\n## At a Glance (Updated)\\n\\n| Dimension | NanoClaw | OpenClaw | MicroClaw |\\n|---|---|---|---|\\n| Orientation | Minimal, skill-first, single-user customization | Personal AI platform with broad channel + node ecosystem | Practical chat runtime, Telegram-first with shared core |\\n| Runtime stack | Node.js + Claude Agent SDK + containers | TypeScript/Node.js control plane + multi-surface stack | Rust + Tokio + unified agent engine |\\n| Channel stance | WhatsApp-first base | Broad native + extension channels | Telegram-first, plus Discord/Web and optional expansions |\\n| Extensibility style | Prefer skills that transform forked code | Platform modules, tools, nodes, apps, and ecosystem surfaces | Built-in tools + skills + sub-agent composition |\\n| Session and memory | Simpler base persistence model | Platform-level session/routing model | Durable sessions + context compaction + layered memory |\\n| Security emphasis | OS-level isolation by default | Policy/pairing/allowlist controls in gateway model | App-level authorization + hardening path |\\n| Ops complexity | Low-to-moderate | Highest (in exchange for capability breadth) | Moderate (feature-rich, but loop architecture remains focused) |\\n\\n## Notable Public Signals (as of 2026-02-14)\\n\\n- NanoClaw README now foregrounds **Agent Swarms** and keeps a strong skill-first philosophy.\\n- OpenClaw README/docs continue expanding multi-channel, node, voice, and canvas workflows.\\n- MicroClaw remains focused on the mid-complexity runtime space: robust agent loop, durable state, and practical operational features.\\n\\n## Choosing by Use Case\\n\\n### Choose NanoClaw if\\n\\n- You want the smallest understandable base and plan to customize by code transformation skills.\\n- You prioritize container-isolation defaults over broad built-in surfaces.\\n\\n### Choose OpenClaw if\\n\\n- You want the widest integrated platform: many channels, nodes, voice, canvas, and gateway tooling.\\n- You accept higher operational and configuration complexity for that breadth.\\n\\n### Choose MicroClaw if\\n\\n- Telegram-centric workflows are your immediate priority.\\n- You want strong session continuity, memory quality, tool orchestration, and scheduler support without adopting the largest platform footprint.\\n\\n## Final Take\\n\\nThis is not a winner-take-all ranking. It is a complexity-placement decision:\\n\\n- NanoClaw: complexity pushed into fork customization\\n- OpenClaw: complexity pushed into platform breadth\\n- MicroClaw: complexity concentrated on high-frequency runtime features\\n\\nPick the one that matches your operations budget and workflow style.\\n\\n## References\\n\\n- NanoClaw: https://github.com/qwibitai/nanoclaw\\n- NanoClaw README: https://raw.githubusercontent.com/qwibitai/nanoclaw/main/README.md\\n- OpenClaw: https://github.com/openclaw/openclaw\\n- OpenClaw Docs: https://docs.openclaw.ai\\n- MicroClaw: https://github.com/microclaw/microclaw\\n- MicroClaw Docs: https://microclaw.ai/docs/overview"},{"id":"/building-microclaw","metadata":{"permalink":"/blog/building-microclaw","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-07-building-microclaw.md","source":"@site/blog/2026-02-07-building-microclaw.md","title":"Building MicroClaw: A Practical Agent Runtime for Telegram and Beyond","description":"MicroClaw is a Rust-based AI assistant that treats chat as an execution surface, not only a text interface.","date":"2026-02-07T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture"},{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":false,"label":"Telegram","permalink":"/blog/tags/telegram"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"}],"readingTime":2.5,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/building-microclaw","title":"Building MicroClaw: A Practical Agent Runtime for Telegram and Beyond","authors":["microclaw"],"tags":["architecture","rust","telegram","agents"]},"unlisted":false,"prevItem":{"title":"MicroClaw vs NanoClaw vs OpenClaw: Updated Three-Path Comparison","permalink":"/blog/microclaw-vs-nanoclaw-openclaw"}},"content":"MicroClaw is a Rust-based AI assistant that treats chat as an execution surface, not only a text interface.\\n\\nIt can run shell and file tools, browse the web, schedule jobs, and persist memory/session state so multi-step work can continue across turns.\\n\\n![MicroClaw runtime overview](/img/blog/refresh-2026-02/01-building-microclaw-overview.svg)\\n\\n\x3c!-- truncate --\x3e\\n\\n## 2026-02-14 Update Snapshot\\n\\nThis post was refreshed on **February 14, 2026** to match the current codebase and docs.\\n\\nCurrent shape:\\n\\n- Shared agent loop with iterative `tool_use` / `tool_result` execution\\n- Channel adapters for Telegram, Discord, and Web API surfaces\\n- Provider abstraction for Anthropic + OpenAI-compatible endpoints\\n- Durable session resume with context compaction\\n- Layered memory: file memory (`AGENTS.md`) + structured SQLite memory\\n- Scheduler + memory reflection background jobs\\n- Usage and memory-observability endpoints for operations\\n\\n## Why This Runtime Exists\\n\\nMost chat bots still behave like single-turn wrappers:\\n\\n1. Receive text\\n2. Produce text\\n3. Lose execution context\\n\\nMicroClaw is built for a different loop:\\n\\n1. Interpret an incoming task\\n2. Decide when tools are needed\\n3. Execute tools and read outputs\\n4. Iterate until done\\n5. Persist state for continuation\\n\\nThat makes it suitable for long-running workflows instead of one-shot Q&A.\\n\\n## Core Capabilities\\n\\n- Chat-native tool execution (`bash`, file ops, search/fetch, scheduler, memory)\\n- Full session resume including prior tool interaction context\\n- Context compaction for long-running conversations\\n- Global and per-chat memory via `AGENTS.md`\\n- Structured memory records in SQLite for queryable recall\\n- One-shot and cron-style scheduled runs\\n- Sub-agent delegation with reduced tool permissions\\n\\n## Runtime Architecture\\n\\nMicroClaw keeps one shared execution core and separates channel concerns into adapters.\\n\\n- **Adapters**: Telegram / Discord / Web handle input-output constraints\\n- **Engine**: shared reasoning and tool loop\\n- **Persistence**: messages, sessions, tasks, memories, observability\\n- **Background workers**: scheduler and memory reflector\\n\\nThis keeps behavior consistent while allowing channels/providers to evolve independently.\\n\\n## Why Rust\\n\\nRust is used here for operational reliability, not novelty:\\n\\n- Explicit concurrency with Tokio for long-lived processes\\n- Predictable shared state boundaries\\n- Strong typing for tool/message/state protocols\\n- Single-binary deployment for simpler operations\\n\\n## Design Principles\\n\\n- `execution-first`: useful assistants should complete tasks, not only chat\\n- `state-is-a-feature`: session and memory quality are first-class\\n- `small-core-practical-edges`: keep core loop clear, add high-frequency features\\n- `layered-safety`: tool-level checks + chat access controls + deployment hardening\\n- `composable-growth`: evolve through tools and skills, avoid loop fragmentation\\n\\n## Real Workflow Examples\\n\\n- \\"Scan this repo for breaking changes and draft release notes.\\"\\n- \\"Weekdays 9am: send me an AI news briefing from selected sources.\\"\\n- \\"Read these logs, identify likely root causes, and propose fixes.\\"\\n- \\"Remember my response style preference and apply it in future sessions.\\"\\n\\n## Current Priorities\\n\\n1. Stronger default boundaries for high-risk tools\\n2. Better cross-channel behavior consistency\\n3. Clearer skill/tool boundary to reduce misuse\\n4. Better failure observability for sessions/scheduler/tools\\n\\n## References\\n\\n- MicroClaw repository: https://github.com/microclaw/microclaw\\n- Overview docs: https://microclaw.ai/docs/overview\\n- Architecture docs: https://microclaw.ai/docs/architecture\\n- Tools docs: https://microclaw.ai/docs/tools"}]}}')}}]);