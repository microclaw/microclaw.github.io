"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2634],{1459(e,s,t){t.r(s),t.d(s,{default:()=>se});var i=t(8774),a=t(4586),n=t(1656),l=t(1107),r=t(6540);const c="hero_aEcG",o="heroBackdrop_oiZR",d="heroPattern_AzbZ",m="heroLayout_anMo",h="heroContent_mKPX",u="eyebrow_kY3W",p="heroTitle_qg2I",x="heroSubtitle_jFu1",j="heroSubtext_Dtnw",b="heroActions_Z2kl",v="darkButton_Km2z",y="heroMetaRow_j4Yq",g="installPanel_i8PT",N="installHeader_QdiW",f="pulseDot_g8rI",w="installTabs_aa5M",k="installTab__WaR",C="installTabActive_QPRE",_="installHint_MeHv",A="installRow_HIB2",S="installCommand_Rf1g",T="copyButton_TrkD",R="copyButtonCopied_Ebdg",M="proofStrip_jmKW",P="proofGrid_VmNn",B="proofLabel_fQbP",L="section_Q9Zo",Q="sectionAlt_Oc16",G="sectionHeader_Gahl",E="capabilityGrid_eKpl",I="capabilityCard_w4Ku",D="archLayout_kFC6",H="archVisualCard_vW6N",W="archSteps_JQSn",F="stepCard_aHS3",U="useCaseGrid_yJI8",q="useCaseCard_t5pd",K="finalCta_eoaB",O="ctaCard_L2rm",V="ctaActions_U5Ze",Z="inlineLink_aysj";var $=t(4848);const z=[{id:"install",label:"Install Script",command:"curl -fsSL https://microclaw.ai/install.sh | bash",hint:"Recommended for macOS/Linux"},{id:"brew",label:"Homebrew",command:"brew tap everettjf/tap && brew install microclaw",hint:"Best for Mac developers"},{id:"cargo",label:"Cargo",command:"git clone https://github.com/microclaw/microclaw.git && cd microclaw && cargo build --release",hint:"Build from source"},{id:"docker",label:"Doctor Check",command:"microclaw doctor --json",hint:"Verify runtime health before production"}],J=[{title:"Channel-Agnostic Core",text:"One shared agent loop drives Telegram, Discord, Slack, Feishu, and Web adapters."},{title:"Tool-Using Agent Loop",text:"The model can chain tools over multiple steps until the task reaches end_turn."},{title:"Memory With Quality Gates",text:"File memory + structured SQLite memory with reflector extraction and dedupe lifecycle."},{title:"Scheduler + Background Tasks",text:"Cron and one-shot tasks run through the same runtime, not a separate automation stack."},{title:"MCP + Skills Federation",text:"Attach external tool servers and domain-specific skills without rewriting the core loop."},{title:"Operational Visibility",text:"Usage and memory observability endpoints help teams track quality and drift over time."}],Y=[{number:"01",title:"Ingest",text:"Channel adapters normalize inbound events into a single runtime format."},{number:"02",title:"Assemble Context",text:"Session state, AGENTS.md memory, structured memory, and active skills are injected."},{number:"03",title:"Reason + Tool Calls",text:"Provider layer streams responses and executes tool calls in a controlled loop."},{number:"04",title:"Persist + Reflect",text:"Conversations, sessions, and memories are persisted; reflector updates durable facts."},{number:"05",title:"Deliver",text:"Responses are split by channel limits and emitted with consistent delivery semantics."}],X=[{title:"Personal Infra Agent",text:"Run one assistant across your chats with memory, scheduling, and shell/file tooling."},{title:"Team Operations Bot",text:"Use permission-aware tools and session history to support recurring internal workflows."},{title:"Product Prototyping Runtime",text:"Ship new channels and tools quickly on a shared Rust core instead of fragmented bots."}];function ee(){const{siteConfig:e}=(0,a.A)(),[s,t]=(0,r.useState)(z[0].id),[n,M]=(0,r.useState)("idle"),P=(0,r.useMemo)(()=>z.find(e=>e.id===s)??z[0],[s]);return(0,$.jsxs)("header",{className:c,children:[(0,$.jsx)("div",{className:o}),(0,$.jsx)("div",{className:d}),(0,$.jsx)("div",{className:"container",children:(0,$.jsxs)("div",{className:m,children:[(0,$.jsxs)("div",{className:h,children:[(0,$.jsx)("div",{className:u,children:"RUST AGENT RUNTIME"}),(0,$.jsx)(l.A,{as:"h1",className:p,children:"Build one agent core. Deploy it to every chat surface."}),(0,$.jsx)("p",{className:x,children:e.tagline}),(0,$.jsx)("p",{className:j,children:"MicroClaw is optimized for teams that need tool-using automation with durable memory, resumable sessions, and channel adapters that do not fork business logic."}),(0,$.jsxs)("div",{className:b,children:[(0,$.jsx)(i.A,{className:"button button--primary button--lg",to:"/docs/quickstart",children:"Start in 5 Minutes"}),(0,$.jsx)(i.A,{className:v,href:"https://github.com/microclaw/microclaw",children:"View GitHub"})]}),(0,$.jsxs)("div",{className:y,children:[(0,$.jsx)("span",{children:"Single Binary"}),(0,$.jsx)("span",{children:"SQLite Persistence"}),(0,$.jsx)("span",{children:"MCP + Skills"})]})]}),(0,$.jsxs)("div",{className:g,children:[(0,$.jsxs)("div",{className:N,children:[(0,$.jsx)("span",{children:"Quickstart CLI"}),(0,$.jsx)("span",{className:f,children:"live"})]}),(0,$.jsx)("div",{className:w,children:z.map(e=>(0,$.jsx)("button",{type:"button",onClick:()=>t(e.id),className:`${k} ${s===e.id?C:""}`,children:e.label},e.id))}),(0,$.jsx)("p",{className:_,children:P.hint}),(0,$.jsxs)("div",{className:A,children:[(0,$.jsx)("code",{className:S,children:P.command}),(0,$.jsx)("button",{className:`${T} ${"copied"===n?R:""}`,type:"button",onClick:async()=>{let e=!1;try{if("undefined"!=typeof navigator&&navigator.clipboard?.writeText)await navigator.clipboard.writeText(P.command),e=!0;else if("undefined"!=typeof document){const s=document.createElement("textarea");s.value=P.command,s.style.position="fixed",s.style.opacity="0",document.body.appendChild(s),s.focus(),s.select(),e=document.execCommand("copy"),document.body.removeChild(s)}}catch{e=!1}e&&(M("copied"),window.setTimeout(()=>M("idle"),1800))},children:"copied"===n?"Copied":"Copy"})]})]})]})})]})}function se(){const{siteConfig:e}=(0,a.A)();return(0,$.jsxs)(n.A,{title:`${e.title}`,description:"MicroClaw is a Rust-first agent runtime for multi-channel chat automation with tools, memory, scheduler, and MCP federation.",children:[(0,$.jsx)(ee,{}),(0,$.jsxs)("main",{children:[(0,$.jsx)("section",{className:M,children:(0,$.jsx)("div",{className:"container",children:(0,$.jsxs)("div",{className:P,children:[(0,$.jsxs)("div",{children:[(0,$.jsx)("span",{className:B,children:"Architecture"}),(0,$.jsx)("p",{children:"Channel-agnostic core with adapter-based delivery"})]}),(0,$.jsxs)("div",{children:[(0,$.jsx)("span",{className:B,children:"Memory"}),(0,$.jsx)("p",{children:"AGENTS.md + SQLite structured memory with observability"})]}),(0,$.jsxs)("div",{children:[(0,$.jsx)("span",{className:B,children:"Execution"}),(0,$.jsx)("p",{children:"Tool loop, sub-agents, scheduling, and background tasks"})]}),(0,$.jsxs)("div",{children:[(0,$.jsx)("span",{className:B,children:"Extensibility"}),(0,$.jsx)("p",{children:"Skills catalog plus MCP tool federation"})]})]})})}),(0,$.jsx)("section",{className:L,children:(0,$.jsxs)("div",{className:"container",children:[(0,$.jsxs)("div",{className:G,children:[(0,$.jsx)(l.A,{as:"h2",children:"Why teams pick MicroClaw"}),(0,$.jsx)("p",{children:"A runtime-centered stack that keeps your logic stable while channels, models, and tools evolve."})]}),(0,$.jsx)("div",{className:E,children:J.map(e=>(0,$.jsxs)("article",{className:I,children:[(0,$.jsx)("h3",{children:e.title}),(0,$.jsx)("p",{children:e.text})]},e.title))})]})}),(0,$.jsx)("section",{className:Q,children:(0,$.jsxs)("div",{className:"container",children:[(0,$.jsxs)("div",{className:G,children:[(0,$.jsx)(l.A,{as:"h2",children:"Runtime architecture at a glance"}),(0,$.jsx)("p",{children:"The same engine powers every conversation, regardless of where users talk to your agent."})]}),(0,$.jsxs)("div",{className:D,children:[(0,$.jsx)("div",{className:H,children:(0,$.jsx)("img",{src:"/img/blog/microclaw-runtime/01-system-architecture.svg",alt:"MicroClaw architecture overview"})}),(0,$.jsx)("div",{className:W,children:Y.map(e=>(0,$.jsxs)("article",{className:F,children:[(0,$.jsx)("span",{children:e.number}),(0,$.jsx)("h3",{children:e.title}),(0,$.jsx)("p",{children:e.text})]},e.number))})]})]})}),(0,$.jsx)("section",{className:L,children:(0,$.jsxs)("div",{className:"container",children:[(0,$.jsxs)("div",{className:G,children:[(0,$.jsx)(l.A,{as:"h2",children:"Use MicroClaw for real workloads"}),(0,$.jsx)("p",{children:"From solo operators to platform teams, one core runtime can cover multiple paths."})]}),(0,$.jsx)("div",{className:U,children:X.map(e=>(0,$.jsxs)("article",{className:q,children:[(0,$.jsx)("h3",{children:e.title}),(0,$.jsx)("p",{children:e.text}),(0,$.jsx)(i.A,{to:"/docs/overview",children:"Read implementation details"})]},e.title))})]})}),(0,$.jsx)("section",{className:K,children:(0,$.jsx)("div",{className:"container",children:(0,$.jsxs)("div",{className:O,children:[(0,$.jsxs)("div",{children:[(0,$.jsx)(l.A,{as:"h2",children:"Ship a production-grade Rust agent stack."}),(0,$.jsx)("p",{children:"Follow Quickstart for setup, then move into tools, permissions, memory, and channel deployment."})]}),(0,$.jsxs)("div",{className:V,children:[(0,$.jsx)(i.A,{className:"button button--primary button--lg",to:"/docs/quickstart",children:"Quickstart"}),(0,$.jsx)(i.A,{className:"button button--secondary button--lg",to:"/docs/architecture",children:"Architecture Docs"}),(0,$.jsx)(i.A,{className:Z,to:"/docs/generated-tools",children:"Generated Tools Reference"})]})]})})})]})]})}}}]);