"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8130],{7735(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/microclaw-vs-nanoclaw-openclaw","metadata":{"permalink":"/blog/microclaw-vs-nanoclaw-openclaw","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-08-microclaw-vs-nanoclaw-openclaw-medium.md","source":"@site/blog/2026-02-08-microclaw-vs-nanoclaw-openclaw-medium.md","title":"MicroClaw vs NanoClaw vs OpenClaw: Three Paths from Minimalism to Platform","description":"If you are building a personal AI assistant that lives inside chat apps, you usually end up on one of three paths:","date":"2026-02-08T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture"},{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":false,"label":"Telegram","permalink":"/blog/tags/telegram"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"},{"inline":true,"label":"comparison","permalink":"/blog/tags/comparison"}],"readingTime":4.47,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/microclaw-vs-nanoclaw-openclaw","title":"MicroClaw vs NanoClaw vs OpenClaw: Three Paths from Minimalism to Platform","authors":["microclaw"],"tags":["architecture","rust","telegram","agents","comparison"]},"unlisted":false,"nextItem":{"title":"MicroClaw vs NanoClaw: A Practical Comparison","permalink":"/blog/microclaw-vs-nanoclaw"}},"content":"If you are building a personal AI assistant that lives inside chat apps, you usually end up on one of three paths:\\n\\n1. Minimal and understandable, with isolation first\\n2. Feature-rich and multi-platform, with ecosystem breadth first\\n3. A middle path with practical built-ins and controlled complexity\\n\\nMicroClaw, NanoClaw, and OpenClaw each sit at different points on that spectrum.\\n\\nThis post compares the three from an engineering perspective, based on publicly available repositories and docs as of February 8, 2026.\\n\\n\x3c!-- truncate --\x3e\\n\\n## TL;DR\\n\\n- If your top priority is minimal code and container isolation, NanoClaw is a strong fit.\\n- If you want a full personal AI platform (many channels, nodes, voice, canvas, control plane), OpenClaw is stronger.\\n- If you want a Telegram-first assistant that is practical, maintainable, and feature-complete for daily use, MicroClaw is the more balanced choice.\\n\\n## At a Glance (Engineering View)\\n\\n| Dimension | NanoClaw | OpenClaw | MicroClaw |\\n|---|---|---|---|\\n| Product orientation | Single-user, minimal, highly understandable | Personal AI platform (control plane + multi-surface ecosystem) | Practical chat agent, Telegram-first |\\n| Primary stack | Node.js + Claude Agent SDK | TypeScript/Node.js platform architecture | Rust + Tokio + teloxide |\\n| Default channel | WhatsApp-first | Multi-channel (WA/Telegram/Slack/Discord/...) | Telegram-first (optional WhatsApp webhook, Discord) |\\n| Model strategy | Closely coupled to Claude Code/Agent SDK workflow | Multi-provider strategy with failover concepts | Native Anthropic + OpenAI-compatible abstraction |\\n| Tool execution | Containerized execution as core principle | Broad tool ecosystem (browser/canvas/nodes/cron, etc.) | Built-in tool registry + sub-agent + skills + todo |\\n| Session model | README emphasizes simplicity/isolation | Platform-level session/gateway/WS control plane | Full session persistence (including `tool_use` / `tool_result`) |\\n| Context management | More skill-driven extension approach | Built-in pruning/session management capabilities | Built-in context compaction for long sessions |\\n| Security emphasis | OS-level isolation (Apple Container/Docker) | Gateway policy + pairing/allowlist + platform controls | App-level auth + chat-level access control + hardening path |\\n| Deployment shape | Claude-driven setup + container dependency | CLI + daemon + companion app/node | Rust single-binary deployment |\\n| Best fit | Builders who want full control of a minimal core | Users who want a maximal capability platform | Developers who want practical features with maintainable complexity |\\n\\n## Why MicroClaw Is Not \u201cAnother OpenClaw\u201d\\n\\nOpenClaw has gone very deep on the \u201cpersonal AI platform\u201d direction: multi-channel support, gateway control plane, nodes, voice, canvas, web surfaces, remote access, and skill ecosystem.\\n\\nThat is not inherently good or bad. It is a complexity budget decision.\\n\\nMicroClaw makes different tradeoffs:\\n\\n- It does not try to cover every surface at once; it optimizes the Telegram path first.\\n- It does not build a heavy control plane first; it prioritizes a robust agent loop, tool execution, session recovery, scheduling, and memory.\\n- It uses Rust and a straightforward process model to reduce hidden runtime state.\\n\\nSo it is not copying OpenClaw. It is optimizing for a different complexity tier.\\n\\n## Why MicroClaw Is Not \u201cNanoClaw in Rust\u201d\\n\\nNanoClaw\u2019s value proposition is clear: keep the core tiny, understandable, and isolation-first, then customize through skills instead of bloating the base.\\n\\nMicroClaw shares the \u201cpersonal assistant should be controllable\u201d philosophy, but applies it differently:\\n\\n- NanoClaw emphasizes minimizing infrastructure.\\n- MicroClaw emphasizes practical built-ins for daily use, including:\\n  - Full session resume with tool interaction context\\n  - Built-in context compaction\\n  - Sub-agents with restricted tool sets\\n  - Planning/todo tools\\n  - On-demand skill activation\\n\\nIn short: NanoClaw pushes minimal core purity; MicroClaw adds one practical layer above that core.\\n\\n## The Core Difference: Where You Place Complexity\\n\\nIn personal AI assistants, complexity does not disappear. You choose where it lives.\\n\\n- NanoClaw puts complexity into your fork-level customization workflow.\\n- OpenClaw puts complexity into platform breadth and ecosystem depth.\\n- MicroClaw puts complexity into built-in high-frequency features while keeping the architecture traceable.\\n\\nThat is why all three can succeed and coexist.\\n\\n## Selection Guide by Real Use Case\\n\\n### Choose NanoClaw if:\\n\\n- You strongly prioritize container isolation boundaries.\\n- You are comfortable adding capabilities via skills and fork-level changes.\\n- You want to understand the core code path quickly.\\n\\n### Choose OpenClaw if:\\n\\n- You need unified access across many channels and device nodes.\\n- You care about voice, canvas, remote gateway, and platform-grade automation.\\n- You are willing to pay higher ops/config complexity for a higher feature ceiling.\\n\\n### Choose MicroClaw if:\\n\\n- Telegram is your primary interface and you want fast time-to-value.\\n- You need tool execution + automation, but also robust session recovery and context management.\\n- You want a better balance between capability and maintainability.\\n\\n## What MicroClaw Should Do Next\\n\\nBased on this comparison, the next high-leverage steps for MicroClaw are not random feature additions:\\n\\n1. Strengthen default safety boundaries for high-risk tools\\n2. Improve behavior consistency across channels (Telegram/WhatsApp/Discord)\\n3. Clarify skill/tool boundaries to reduce prompt overhead and misuse\\n4. Improve observability for scheduler/session/tool failures\\n\\nThe goal is not to become OpenClaw. The goal is to make the \u201cmid-complexity, high-utility assistant\u201d category more reliable.\\n\\n## Final Take\\n\\nThis is not a \u201cwhich one is best\u201d debate. It is a \u201cwhat kind of assistant do you want to operate\u201d decision.\\n\\n- If you want a controllable scalpel: NanoClaw  \\n- If you want a powerful workstation platform: OpenClaw  \\n- If you want a dependable daily engineering vehicle: MicroClaw\\n\\nChoosing the right path matters more than chasing feature trends.\\n\\n## References\\n\\n- NanoClaw: https://github.com/gavrielc/nanoclaw\\n- NanoClaw README: https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md\\n- OpenClaw: https://github.com/openclaw/openclaw\\n- OpenClaw Docs: https://docs.openclaw.ai\\n- MicroClaw: https://github.com/microclaw/microclaw"},{"id":"/microclaw-vs-nanoclaw","metadata":{"permalink":"/blog/microclaw-vs-nanoclaw","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-08-microclaw-vs-nanoclaw.md","source":"@site/blog/2026-02-08-microclaw-vs-nanoclaw.md","title":"MicroClaw vs NanoClaw: A Practical Comparison","description":"MicroClaw was inspired by NanoClaw. They share the same core idea: an AI assistant that can execute tools from chat.","date":"2026-02-08T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture"},{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":false,"label":"Chat","permalink":"/blog/tags/chat"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"}],"readingTime":2.52,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/microclaw-vs-nanoclaw","title":"MicroClaw vs NanoClaw: A Practical Comparison","authors":["microclaw"],"tags":["architecture","rust","chat","agents"]},"unlisted":false,"prevItem":{"title":"MicroClaw vs NanoClaw vs OpenClaw: Three Paths from Minimalism to Platform","permalink":"/blog/microclaw-vs-nanoclaw-openclaw"},"nextItem":{"title":"Introducing MicroClaw: An Agentic AI Assistant for Telegram","permalink":"/blog/building-microclaw"}},"content":"MicroClaw was inspired by [NanoClaw](https://github.com/gavrielc/nanoclaw/). They share the same core idea: an AI assistant that can execute tools from chat.\\n\\nThis post compares the two projects from an engineering and product perspective, based on current public documentation.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Scope note\\n\\nThe NanoClaw side of this comparison is based on its official README as of February 8, 2026. If NanoClaw changes later, some rows may evolve.\\n\\n## Comparison table\\n\\n| Dimension | NanoClaw | MicroClaw |\\n|---|---|---|\\n| Project orientation | Minimal, single-user, \\"small enough to understand\\" | Broader chat-agent feature set for practical daily use |\\n| Relationship | Original project | Inspired by NanoClaw and expanded for Rust + Telegram workflows |\\n| Default channel | WhatsApp-first | Telegram-first (with optional WhatsApp Cloud webhook support) |\\n| Multi-channel philosophy | Prefer transformation skills (for example `/add-telegram`) over built-in multi-channel complexity | Built as a chat-surface bot with Telegram as primary experience |\\n| Primary stack | Node.js + Claude Agent SDK + container runtime | Rust + Tokio + teloxide + reqwest |\\n| Model/provider strategy | Tied to Claude Code / Agent SDK workflow | Native Anthropic + OpenAI-compatible provider abstraction |\\n| Tool system | README describes major capabilities (web, scheduling, etc.) | Explicit tool registry with file, shell, web, memory, scheduler, export, sub-agent, todo, and skills tools |\\n| Agent execution loop | Agent runs through containerized Claude workflow | Explicit `tool_use` / `tool_result` loop with iteration cap |\\n| Security posture emphasis | OS-level isolation via Apple Container/Docker sandboxes | In-app tool authorization + deployment hardening strategies |\\n| Host access model | Commands run inside container with mounted scope | Commands/tools run in runtime environment; boundaries enforced by auth and ops controls |\\n| Persistence | SQLite | SQLite (messages, chats, sessions, scheduled tasks, etc.) |\\n| Session continuity | Persistent behavior implied; less emphasis on tool-block replay details in README | Full session resume including tool interaction context |\\n| Context compaction | Mentioned as a skill direction (`/add-clear`) | Built-in context compaction for oversized sessions |\\n| Memory structure | Per-group `CLAUDE.md` with isolation focus | Global + per-chat `CLAUDE.md` scopes |\\n| Scheduler | Recurring task support | One-shot + cron recurring tasks with management tools |\\n| Sub-agent capability | Not explicitly documented in README | Built-in `sub_agent` with restricted tool set |\\n| Planning/todo tools | Not explicitly documented in README | Built-in todo read/write tools |\\n| Extensibility model | \\"Skills over features\\" is a core principle | Supports skill activation while also shipping broader built-in capabilities |\\n| Configuration philosophy | Fewer knobs; customize by code changes | Config-driven runtime with provider/model/authorization options |\\n| Deployment shape | Claude Code-centric + container requirements | Single-binary Rust deployment path (`cargo build --release`) |\\n| Best fit | Users who want container-isolated, minimal, deeply personalized forks | Users who want rich Telegram-native agent workflows with built-in operational features |\\n\\n## Bottom line\\n\\nNanoClaw optimizes for minimalism and container isolation first.\\n\\nMicroClaw optimizes for built-in capability breadth and Telegram-first agent workflows.\\n\\nBoth are valid choices. The right one depends on whether your top priority is minimal isolated substrate (NanoClaw) or broader integrated functionality out of the box (MicroClaw).\\n\\n## References\\n\\n- NanoClaw repository: https://github.com/gavrielc/nanoclaw/\\n- NanoClaw README (raw): https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md\\n- MicroClaw repository: https://github.com/microclaw/microclaw\\n- MicroClaw docs: https://microclaw.ai/docs/overview"},{"id":"/building-microclaw","metadata":{"permalink":"/blog/building-microclaw","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-07-building-microclaw.md","source":"@site/blog/2026-02-07-building-microclaw.md","title":"Introducing MicroClaw: An Agentic AI Assistant for Telegram","description":"MicroClaw is a Rust-based AI assistant that lives directly in your Telegram chats. Instead of only answering text prompts, it can use tools to complete multi-step tasks: run shell commands, read and edit files, search code, browse the web, schedule jobs, and keep persistent memory.","date":"2026-02-07T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture"},{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":false,"label":"Telegram","permalink":"/blog/tags/telegram"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"}],"readingTime":1.72,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/building-microclaw","title":"Introducing MicroClaw: An Agentic AI Assistant for Telegram","authors":["microclaw"],"tags":["architecture","rust","telegram","agents"]},"unlisted":false,"prevItem":{"title":"MicroClaw vs NanoClaw: A Practical Comparison","permalink":"/blog/microclaw-vs-nanoclaw"}},"content":"MicroClaw is a Rust-based AI assistant that lives directly in your Telegram chats. Instead of only answering text prompts, it can use tools to complete multi-step tasks: run shell commands, read and edit files, search code, browse the web, schedule jobs, and keep persistent memory.\\n\\nThis post is a short project introduction: what MicroClaw is, how it works, and why the architecture is built this way.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What problem it solves\\n\\nMost chat bots are single-turn wrappers around an LLM API: send user text in, send model text out.\\n\\nMicroClaw uses an agent loop. For each user message, the model can:\\n\\n1. Decide whether to answer directly or call a tool\\n2. Execute one or more tools\\n3. Read tool results\\n4. Continue iterating until the task is complete\\n\\nThat loop turns chat from Q&A into execution.\\n\\n## Core capabilities\\n\\n- Tool execution in chat (`bash`, file ops, `glob`, `grep`, web tools)\\n- Session resume with full tool-call context persisted in SQLite\\n- Context compaction when sessions grow large\\n- Persistent memory via global and per-chat `CLAUDE.md`\\n- Scheduled tasks (one-shot and cron)\\n- Sub-agent execution with a restricted tool set\\n\\n## High-level architecture\\n\\nAt a high level, each message flows through the same pipeline:\\n\\n1. Store message in SQLite\\n2. Load session/history + memory\\n3. Call LLM with tool definitions\\n4. If tool use is requested, execute tool and loop\\n5. When LLM ends turn, return response to chat\\n\\nThe same agent loop is reused by the scheduler, so scheduled jobs can also use tools and reasoning.\\n\\n## Why Rust\\n\\nMicroClaw is written in Rust for operational simplicity and reliability:\\n\\n- Single binary deployment (`cargo build --release`)\\n- Strong typing for message blocks (`text`, `tool_use`, `tool_result`)\\n- Clear shared-state boundaries (`Arc<Database>`)\\n- Predictable async runtime behavior with Tokio\\n\\n## Project status\\n\\nMicroClaw is under active development. Current focus areas are improving onboarding, hardening runtime safety defaults, and making multi-chat operations more robust.\\n\\nIf you want to explore the full docs, start here:\\n\\n- https://microclaw.ai/docs/overview\\n- https://microclaw.ai/docs/architecture\\n- https://microclaw.ai/docs/tools"}]}}')}}]);