"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8130],{7735(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/microclaw-vs-nanoclaw","metadata":{"permalink":"/blog/microclaw-vs-nanoclaw","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-08-microclaw-vs-nanoclaw.md","source":"@site/blog/2026-02-08-microclaw-vs-nanoclaw.md","title":"MicroClaw vs NanoClaw: A Practical Comparison","description":"MicroClaw was inspired by NanoClaw. They share the same core idea: an AI assistant that can execute tools from chat.","date":"2026-02-08T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture"},{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":false,"label":"Chat","permalink":"/blog/tags/chat"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"}],"readingTime":2.52,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/microclaw-vs-nanoclaw","title":"MicroClaw vs NanoClaw: A Practical Comparison","authors":["microclaw"],"tags":["architecture","rust","chat","agents"]},"unlisted":false,"nextItem":{"title":"Introducing MicroClaw: An Agentic AI Assistant for Telegram","permalink":"/blog/building-microclaw"}},"content":"MicroClaw was inspired by [NanoClaw](https://github.com/gavrielc/nanoclaw/). They share the same core idea: an AI assistant that can execute tools from chat.\\n\\nThis post compares the two projects from an engineering and product perspective, based on current public documentation.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Scope note\\n\\nThe NanoClaw side of this comparison is based on its official README as of February 8, 2026. If NanoClaw changes later, some rows may evolve.\\n\\n## Comparison table\\n\\n| Dimension | NanoClaw | MicroClaw |\\n|---|---|---|\\n| Project orientation | Minimal, single-user, \\"small enough to understand\\" | Broader chat-agent feature set for practical daily use |\\n| Relationship | Original project | Inspired by NanoClaw and expanded for Rust + Telegram workflows |\\n| Default channel | WhatsApp-first | Telegram-first (with optional WhatsApp Cloud webhook support) |\\n| Multi-channel philosophy | Prefer transformation skills (for example `/add-telegram`) over built-in multi-channel complexity | Built as a chat-surface bot with Telegram as primary experience |\\n| Primary stack | Node.js + Claude Agent SDK + container runtime | Rust + Tokio + teloxide + reqwest |\\n| Model/provider strategy | Tied to Claude Code / Agent SDK workflow | Native Anthropic + OpenAI-compatible provider abstraction |\\n| Tool system | README describes major capabilities (web, scheduling, etc.) | Explicit tool registry with file, shell, web, memory, scheduler, export, sub-agent, todo, and skills tools |\\n| Agent execution loop | Agent runs through containerized Claude workflow | Explicit `tool_use` / `tool_result` loop with iteration cap |\\n| Security posture emphasis | OS-level isolation via Apple Container/Docker sandboxes | In-app tool authorization + deployment hardening strategies |\\n| Host access model | Commands run inside container with mounted scope | Commands/tools run in runtime environment; boundaries enforced by auth and ops controls |\\n| Persistence | SQLite | SQLite (messages, chats, sessions, scheduled tasks, etc.) |\\n| Session continuity | Persistent behavior implied; less emphasis on tool-block replay details in README | Full session resume including tool interaction context |\\n| Context compaction | Mentioned as a skill direction (`/add-clear`) | Built-in context compaction for oversized sessions |\\n| Memory structure | Per-group `CLAUDE.md` with isolation focus | Global + per-chat `CLAUDE.md` scopes |\\n| Scheduler | Recurring task support | One-shot + cron recurring tasks with management tools |\\n| Sub-agent capability | Not explicitly documented in README | Built-in `sub_agent` with restricted tool set |\\n| Planning/todo tools | Not explicitly documented in README | Built-in todo read/write tools |\\n| Extensibility model | \\"Skills over features\\" is a core principle | Supports skill activation while also shipping broader built-in capabilities |\\n| Configuration philosophy | Fewer knobs; customize by code changes | Config-driven runtime with provider/model/authorization options |\\n| Deployment shape | Claude Code-centric + container requirements | Single-binary Rust deployment path (`cargo build --release`) |\\n| Best fit | Users who want container-isolated, minimal, deeply personalized forks | Users who want rich Telegram-native agent workflows with built-in operational features |\\n\\n## Bottom line\\n\\nNanoClaw optimizes for minimalism and container isolation first.\\n\\nMicroClaw optimizes for built-in capability breadth and Telegram-first agent workflows.\\n\\nBoth are valid choices. The right one depends on whether your top priority is minimal isolated substrate (NanoClaw) or broader integrated functionality out of the box (MicroClaw).\\n\\n## References\\n\\n- NanoClaw repository: https://github.com/gavrielc/nanoclaw/\\n- NanoClaw README (raw): https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md\\n- MicroClaw repository: https://github.com/microclaw/microclaw\\n- MicroClaw docs: https://microclaw.ai/docs/overview"},{"id":"/building-microclaw","metadata":{"permalink":"/blog/building-microclaw","editUrl":"https://github.com/microclaw/microclaw/tree/main/blog/2026-02-07-building-microclaw.md","source":"@site/blog/2026-02-07-building-microclaw.md","title":"Introducing MicroClaw: An Agentic AI Assistant for Telegram","description":"MicroClaw is a Rust-based AI assistant that lives directly in your Telegram chats. Instead of only answering text prompts, it can use tools to complete multi-step tasks: run shell commands, read and edit files, search code, browse the web, schedule jobs, and keep persistent memory.","date":"2026-02-07T00:00:00.000Z","tags":[{"inline":false,"label":"Architecture","permalink":"/blog/tags/architecture"},{"inline":false,"label":"Rust","permalink":"/blog/tags/rust"},{"inline":false,"label":"Telegram","permalink":"/blog/tags/telegram"},{"inline":false,"label":"Agentic AI","permalink":"/blog/tags/agents"}],"readingTime":1.72,"hasTruncateMarker":true,"authors":[{"name":"Everett","title":"MicroClaw Maintainer","url":"https://github.com/microclaw","socials":{"x":"https://x.com/everettjf","discord":"https://discord.gg/pvmezwkAk5"},"page":{"permalink":"/blog/authors/microclaw"},"imageURL":"https://github.com/microclaw.png","key":"microclaw"}],"frontMatter":{"slug":"/building-microclaw","title":"Introducing MicroClaw: An Agentic AI Assistant for Telegram","authors":["microclaw"],"tags":["architecture","rust","telegram","agents"]},"unlisted":false,"prevItem":{"title":"MicroClaw vs NanoClaw: A Practical Comparison","permalink":"/blog/microclaw-vs-nanoclaw"}},"content":"MicroClaw is a Rust-based AI assistant that lives directly in your Telegram chats. Instead of only answering text prompts, it can use tools to complete multi-step tasks: run shell commands, read and edit files, search code, browse the web, schedule jobs, and keep persistent memory.\\n\\nThis post is a short project introduction: what MicroClaw is, how it works, and why the architecture is built this way.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What problem it solves\\n\\nMost chat bots are single-turn wrappers around an LLM API: send user text in, send model text out.\\n\\nMicroClaw uses an agent loop. For each user message, the model can:\\n\\n1. Decide whether to answer directly or call a tool\\n2. Execute one or more tools\\n3. Read tool results\\n4. Continue iterating until the task is complete\\n\\nThat loop turns chat from Q&A into execution.\\n\\n## Core capabilities\\n\\n- Tool execution in chat (`bash`, file ops, `glob`, `grep`, web tools)\\n- Session resume with full tool-call context persisted in SQLite\\n- Context compaction when sessions grow large\\n- Persistent memory via global and per-chat `CLAUDE.md`\\n- Scheduled tasks (one-shot and cron)\\n- Sub-agent execution with a restricted tool set\\n\\n## High-level architecture\\n\\nAt a high level, each message flows through the same pipeline:\\n\\n1. Store message in SQLite\\n2. Load session/history + memory\\n3. Call LLM with tool definitions\\n4. If tool use is requested, execute tool and loop\\n5. When LLM ends turn, return response to chat\\n\\nThe same agent loop is reused by the scheduler, so scheduled jobs can also use tools and reasoning.\\n\\n## Why Rust\\n\\nMicroClaw is written in Rust for operational simplicity and reliability:\\n\\n- Single binary deployment (`cargo build --release`)\\n- Strong typing for message blocks (`text`, `tool_use`, `tool_result`)\\n- Clear shared-state boundaries (`Arc<Database>`)\\n- Predictable async runtime behavior with Tokio\\n\\n## Project status\\n\\nMicroClaw is under active development. Current focus areas are improving onboarding, hardening runtime safety defaults, and making multi-chat operations more robust.\\n\\nIf you want to explore the full docs, start here:\\n\\n- https://microclaw.ai/docs/overview\\n- https://microclaw.ai/docs/architecture\\n- https://microclaw.ai/docs/tools"}]}}')}}]);