<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="rss.xsl"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>MicroClaw Blog</title>
        <link>https://microclaw.ai/blog</link>
        <description>MicroClaw Blog</description>
        <lastBuildDate>Sun, 08 Feb 2026 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[MicroClaw vs NanoClaw vs OpenClaw: Three Paths from Minimalism to Platform]]></title>
            <link>https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw</link>
            <guid>https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw</guid>
            <pubDate>Sun, 08 Feb 2026 00:00:00 GMT</pubDate>
            <description><![CDATA[If you are building a personal AI assistant that lives inside chat apps, you usually end up on one of three paths:]]></description>
            <content:encoded><![CDATA[<p>If you are building a personal AI assistant that lives inside chat apps, you usually end up on one of three paths:</p>
<ol>
<li class="">Minimal and understandable, with isolation first</li>
<li class="">Feature-rich and multi-platform, with ecosystem breadth first</li>
<li class="">A middle path with practical built-ins and controlled complexity</li>
</ol>
<p>MicroClaw, NanoClaw, and OpenClaw each sit at different points on that spectrum.</p>
<p>This post compares the three from an engineering perspective, based on publicly available repositories and docs as of February 8, 2026.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="tldr">TL;DR<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#tldr" class="hash-link" aria-label="Direct link to TL;DR" title="Direct link to TL;DR" translate="no">​</a></h2>
<ul>
<li class="">If your top priority is minimal code and container isolation, NanoClaw is a strong fit.</li>
<li class="">If you want a full personal AI platform (many channels, nodes, voice, canvas, control plane), OpenClaw is stronger.</li>
<li class="">If you want a Telegram-first assistant that is practical, maintainable, and feature-complete for daily use, MicroClaw is the more balanced choice.</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="at-a-glance-engineering-view">At a Glance (Engineering View)<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#at-a-glance-engineering-view" class="hash-link" aria-label="Direct link to At a Glance (Engineering View)" title="Direct link to At a Glance (Engineering View)" translate="no">​</a></h2>
<table><thead><tr><th>Dimension</th><th>NanoClaw</th><th>OpenClaw</th><th>MicroClaw</th></tr></thead><tbody><tr><td>Product orientation</td><td>Single-user, minimal, highly understandable</td><td>Personal AI platform (control plane + multi-surface ecosystem)</td><td>Practical chat agent, Telegram-first</td></tr><tr><td>Primary stack</td><td>Node.js + Claude Agent SDK</td><td>TypeScript/Node.js platform architecture</td><td>Rust + Tokio + teloxide</td></tr><tr><td>Default channel</td><td>WhatsApp-first</td><td>Multi-channel (WA/Telegram/Slack/Discord/...)</td><td>Telegram-first (optional WhatsApp webhook, Discord)</td></tr><tr><td>Model strategy</td><td>Closely coupled to Claude Code/Agent SDK workflow</td><td>Multi-provider strategy with failover concepts</td><td>Native Anthropic + OpenAI-compatible abstraction</td></tr><tr><td>Tool execution</td><td>Containerized execution as core principle</td><td>Broad tool ecosystem (browser/canvas/nodes/cron, etc.)</td><td>Built-in tool registry + sub-agent + skills + todo</td></tr><tr><td>Session model</td><td>README emphasizes simplicity/isolation</td><td>Platform-level session/gateway/WS control plane</td><td>Full session persistence (including <code>tool_use</code> / <code>tool_result</code>)</td></tr><tr><td>Context management</td><td>More skill-driven extension approach</td><td>Built-in pruning/session management capabilities</td><td>Built-in context compaction for long sessions</td></tr><tr><td>Security emphasis</td><td>OS-level isolation (Apple Container/Docker)</td><td>Gateway policy + pairing/allowlist + platform controls</td><td>App-level auth + chat-level access control + hardening path</td></tr><tr><td>Deployment shape</td><td>Claude-driven setup + container dependency</td><td>CLI + daemon + companion app/node</td><td>Rust single-binary deployment</td></tr><tr><td>Best fit</td><td>Builders who want full control of a minimal core</td><td>Users who want a maximal capability platform</td><td>Developers who want practical features with maintainable complexity</td></tr></tbody></table>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="why-microclaw-is-not-another-openclaw">Why MicroClaw Is Not “Another OpenClaw”<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#why-microclaw-is-not-another-openclaw" class="hash-link" aria-label="Direct link to Why MicroClaw Is Not “Another OpenClaw”" title="Direct link to Why MicroClaw Is Not “Another OpenClaw”" translate="no">​</a></h2>
<p>OpenClaw has gone very deep on the “personal AI platform” direction: multi-channel support, gateway control plane, nodes, voice, canvas, web surfaces, remote access, and skill ecosystem.</p>
<p>That is not inherently good or bad. It is a complexity budget decision.</p>
<p>MicroClaw makes different tradeoffs:</p>
<ul>
<li class="">It does not try to cover every surface at once; it optimizes the Telegram path first.</li>
<li class="">It does not build a heavy control plane first; it prioritizes a robust agent loop, tool execution, session recovery, scheduling, and memory.</li>
<li class="">It uses Rust and a straightforward process model to reduce hidden runtime state.</li>
</ul>
<p>So it is not copying OpenClaw. It is optimizing for a different complexity tier.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="why-microclaw-is-not-nanoclaw-in-rust">Why MicroClaw Is Not “NanoClaw in Rust”<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#why-microclaw-is-not-nanoclaw-in-rust" class="hash-link" aria-label="Direct link to Why MicroClaw Is Not “NanoClaw in Rust”" title="Direct link to Why MicroClaw Is Not “NanoClaw in Rust”" translate="no">​</a></h2>
<p>NanoClaw’s value proposition is clear: keep the core tiny, understandable, and isolation-first, then customize through skills instead of bloating the base.</p>
<p>MicroClaw shares the “personal assistant should be controllable” philosophy, but applies it differently:</p>
<ul>
<li class="">NanoClaw emphasizes minimizing infrastructure.</li>
<li class="">MicroClaw emphasizes practical built-ins for daily use, including:<!-- -->
<ul>
<li class="">Full session resume with tool interaction context</li>
<li class="">Built-in context compaction</li>
<li class="">Sub-agents with restricted tool sets</li>
<li class="">Planning/todo tools</li>
<li class="">On-demand skill activation</li>
</ul>
</li>
</ul>
<p>In short: NanoClaw pushes minimal core purity; MicroClaw adds one practical layer above that core.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-core-difference-where-you-place-complexity">The Core Difference: Where You Place Complexity<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#the-core-difference-where-you-place-complexity" class="hash-link" aria-label="Direct link to The Core Difference: Where You Place Complexity" title="Direct link to The Core Difference: Where You Place Complexity" translate="no">​</a></h2>
<p>In personal AI assistants, complexity does not disappear. You choose where it lives.</p>
<ul>
<li class="">NanoClaw puts complexity into your fork-level customization workflow.</li>
<li class="">OpenClaw puts complexity into platform breadth and ecosystem depth.</li>
<li class="">MicroClaw puts complexity into built-in high-frequency features while keeping the architecture traceable.</li>
</ul>
<p>That is why all three can succeed and coexist.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="selection-guide-by-real-use-case">Selection Guide by Real Use Case<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#selection-guide-by-real-use-case" class="hash-link" aria-label="Direct link to Selection Guide by Real Use Case" title="Direct link to Selection Guide by Real Use Case" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="choose-nanoclaw-if">Choose NanoClaw if:<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#choose-nanoclaw-if" class="hash-link" aria-label="Direct link to Choose NanoClaw if:" title="Direct link to Choose NanoClaw if:" translate="no">​</a></h3>
<ul>
<li class="">You strongly prioritize container isolation boundaries.</li>
<li class="">You are comfortable adding capabilities via skills and fork-level changes.</li>
<li class="">You want to understand the core code path quickly.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="choose-openclaw-if">Choose OpenClaw if:<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#choose-openclaw-if" class="hash-link" aria-label="Direct link to Choose OpenClaw if:" title="Direct link to Choose OpenClaw if:" translate="no">​</a></h3>
<ul>
<li class="">You need unified access across many channels and device nodes.</li>
<li class="">You care about voice, canvas, remote gateway, and platform-grade automation.</li>
<li class="">You are willing to pay higher ops/config complexity for a higher feature ceiling.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="choose-microclaw-if">Choose MicroClaw if:<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#choose-microclaw-if" class="hash-link" aria-label="Direct link to Choose MicroClaw if:" title="Direct link to Choose MicroClaw if:" translate="no">​</a></h3>
<ul>
<li class="">Telegram is your primary interface and you want fast time-to-value.</li>
<li class="">You need tool execution + automation, but also robust session recovery and context management.</li>
<li class="">You want a better balance between capability and maintainability.</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="what-microclaw-should-do-next">What MicroClaw Should Do Next<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#what-microclaw-should-do-next" class="hash-link" aria-label="Direct link to What MicroClaw Should Do Next" title="Direct link to What MicroClaw Should Do Next" translate="no">​</a></h2>
<p>Based on this comparison, the next high-leverage steps for MicroClaw are not random feature additions:</p>
<ol>
<li class="">Strengthen default safety boundaries for high-risk tools</li>
<li class="">Improve behavior consistency across channels (Telegram/WhatsApp/Discord)</li>
<li class="">Clarify skill/tool boundaries to reduce prompt overhead and misuse</li>
<li class="">Improve observability for scheduler/session/tool failures</li>
</ol>
<p>The goal is not to become OpenClaw. The goal is to make the “mid-complexity, high-utility assistant” category more reliable.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="final-take">Final Take<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#final-take" class="hash-link" aria-label="Direct link to Final Take" title="Direct link to Final Take" translate="no">​</a></h2>
<p>This is not a “which one is best” debate. It is a “what kind of assistant do you want to operate” decision.</p>
<ul>
<li class="">If you want a controllable scalpel: NanoClaw</li>
<li class="">If you want a powerful workstation platform: OpenClaw</li>
<li class="">If you want a dependable daily engineering vehicle: MicroClaw</li>
</ul>
<p>Choosing the right path matters more than chasing feature trends.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="references">References<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#references" class="hash-link" aria-label="Direct link to References" title="Direct link to References" translate="no">​</a></h2>
<ul>
<li class="">NanoClaw: <a href="https://github.com/gavrielc/nanoclaw" target="_blank" rel="noopener noreferrer" class="">https://github.com/gavrielc/nanoclaw</a></li>
<li class="">NanoClaw README: <a href="https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md" target="_blank" rel="noopener noreferrer" class="">https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md</a></li>
<li class="">OpenClaw: <a href="https://github.com/openclaw/openclaw" target="_blank" rel="noopener noreferrer" class="">https://github.com/openclaw/openclaw</a></li>
<li class="">OpenClaw Docs: <a href="https://docs.openclaw.ai/" target="_blank" rel="noopener noreferrer" class="">https://docs.openclaw.ai</a></li>
<li class="">MicroClaw: <a href="https://github.com/microclaw/microclaw" target="_blank" rel="noopener noreferrer" class="">https://github.com/microclaw/microclaw</a></li>
</ul>]]></content:encoded>
            <category>Architecture</category>
            <category>Rust</category>
            <category>Telegram</category>
            <category>Agentic AI</category>
            <category>comparison</category>
        </item>
        <item>
            <title><![CDATA[MicroClaw vs NanoClaw: A Practical Comparison]]></title>
            <link>https://microclaw.ai/blog/microclaw-vs-nanoclaw</link>
            <guid>https://microclaw.ai/blog/microclaw-vs-nanoclaw</guid>
            <pubDate>Sun, 08 Feb 2026 00:00:00 GMT</pubDate>
            <description><![CDATA[MicroClaw was inspired by NanoClaw. They share the same core idea: an AI assistant that can execute tools from chat.]]></description>
            <content:encoded><![CDATA[<p>MicroClaw was inspired by <a href="https://github.com/gavrielc/nanoclaw/" target="_blank" rel="noopener noreferrer" class="">NanoClaw</a>. They share the same core idea: an AI assistant that can execute tools from chat.</p>
<p>This post compares the two projects from an engineering and product perspective, based on current public documentation.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="scope-note">Scope note<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw#scope-note" class="hash-link" aria-label="Direct link to Scope note" title="Direct link to Scope note" translate="no">​</a></h2>
<p>The NanoClaw side of this comparison is based on its official README as of February 8, 2026. If NanoClaw changes later, some rows may evolve.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="comparison-table">Comparison table<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw#comparison-table" class="hash-link" aria-label="Direct link to Comparison table" title="Direct link to Comparison table" translate="no">​</a></h2>
<table><thead><tr><th>Dimension</th><th>NanoClaw</th><th>MicroClaw</th></tr></thead><tbody><tr><td>Project orientation</td><td>Minimal, single-user, "small enough to understand"</td><td>Broader chat-agent feature set for practical daily use</td></tr><tr><td>Relationship</td><td>Original project</td><td>Inspired by NanoClaw and expanded for Rust + Telegram workflows</td></tr><tr><td>Default channel</td><td>WhatsApp-first</td><td>Telegram-first (with optional WhatsApp Cloud webhook support)</td></tr><tr><td>Multi-channel philosophy</td><td>Prefer transformation skills (for example <code>/add-telegram</code>) over built-in multi-channel complexity</td><td>Built as a chat-surface bot with Telegram as primary experience</td></tr><tr><td>Primary stack</td><td>Node.js + Claude Agent SDK + container runtime</td><td>Rust + Tokio + teloxide + reqwest</td></tr><tr><td>Model/provider strategy</td><td>Tied to Claude Code / Agent SDK workflow</td><td>Native Anthropic + OpenAI-compatible provider abstraction</td></tr><tr><td>Tool system</td><td>README describes major capabilities (web, scheduling, etc.)</td><td>Explicit tool registry with file, shell, web, memory, scheduler, export, sub-agent, todo, and skills tools</td></tr><tr><td>Agent execution loop</td><td>Agent runs through containerized Claude workflow</td><td>Explicit <code>tool_use</code> / <code>tool_result</code> loop with iteration cap</td></tr><tr><td>Security posture emphasis</td><td>OS-level isolation via Apple Container/Docker sandboxes</td><td>In-app tool authorization + deployment hardening strategies</td></tr><tr><td>Host access model</td><td>Commands run inside container with mounted scope</td><td>Commands/tools run in runtime environment; boundaries enforced by auth and ops controls</td></tr><tr><td>Persistence</td><td>SQLite</td><td>SQLite (messages, chats, sessions, scheduled tasks, etc.)</td></tr><tr><td>Session continuity</td><td>Persistent behavior implied; less emphasis on tool-block replay details in README</td><td>Full session resume including tool interaction context</td></tr><tr><td>Context compaction</td><td>Mentioned as a skill direction (<code>/add-clear</code>)</td><td>Built-in context compaction for oversized sessions</td></tr><tr><td>Memory structure</td><td>Per-group <code>CLAUDE.md</code> with isolation focus</td><td>Global + per-chat <code>CLAUDE.md</code> scopes</td></tr><tr><td>Scheduler</td><td>Recurring task support</td><td>One-shot + cron recurring tasks with management tools</td></tr><tr><td>Sub-agent capability</td><td>Not explicitly documented in README</td><td>Built-in <code>sub_agent</code> with restricted tool set</td></tr><tr><td>Planning/todo tools</td><td>Not explicitly documented in README</td><td>Built-in todo read/write tools</td></tr><tr><td>Extensibility model</td><td>"Skills over features" is a core principle</td><td>Supports skill activation while also shipping broader built-in capabilities</td></tr><tr><td>Configuration philosophy</td><td>Fewer knobs; customize by code changes</td><td>Config-driven runtime with provider/model/authorization options</td></tr><tr><td>Deployment shape</td><td>Claude Code-centric + container requirements</td><td>Single-binary Rust deployment path (<code>cargo build --release</code>)</td></tr><tr><td>Best fit</td><td>Users who want container-isolated, minimal, deeply personalized forks</td><td>Users who want rich Telegram-native agent workflows with built-in operational features</td></tr></tbody></table>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="bottom-line">Bottom line<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw#bottom-line" class="hash-link" aria-label="Direct link to Bottom line" title="Direct link to Bottom line" translate="no">​</a></h2>
<p>NanoClaw optimizes for minimalism and container isolation first.</p>
<p>MicroClaw optimizes for built-in capability breadth and Telegram-first agent workflows.</p>
<p>Both are valid choices. The right one depends on whether your top priority is minimal isolated substrate (NanoClaw) or broader integrated functionality out of the box (MicroClaw).</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="references">References<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw#references" class="hash-link" aria-label="Direct link to References" title="Direct link to References" translate="no">​</a></h2>
<ul>
<li class="">NanoClaw repository: <a href="https://github.com/gavrielc/nanoclaw/" target="_blank" rel="noopener noreferrer" class="">https://github.com/gavrielc/nanoclaw/</a></li>
<li class="">NanoClaw README (raw): <a href="https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md" target="_blank" rel="noopener noreferrer" class="">https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md</a></li>
<li class="">MicroClaw repository: <a href="https://github.com/microclaw/microclaw" target="_blank" rel="noopener noreferrer" class="">https://github.com/microclaw/microclaw</a></li>
<li class="">MicroClaw docs: <a href="https://microclaw.ai/docs/overview" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/overview</a></li>
</ul>]]></content:encoded>
            <category>Architecture</category>
            <category>Rust</category>
            <category>Chat</category>
            <category>Agentic AI</category>
        </item>
        <item>
            <title><![CDATA[Introducing MicroClaw: An Agentic AI Assistant for Telegram]]></title>
            <link>https://microclaw.ai/blog/building-microclaw</link>
            <guid>https://microclaw.ai/blog/building-microclaw</guid>
            <pubDate>Sat, 07 Feb 2026 00:00:00 GMT</pubDate>
            <description><![CDATA[MicroClaw is a Rust-based AI assistant that lives directly in your Telegram chats. Instead of only answering text prompts, it can use tools to complete multi-step tasks: run shell commands, read and edit files, search code, browse the web, schedule jobs, and keep persistent memory.]]></description>
            <content:encoded><![CDATA[<p>MicroClaw is a Rust-based AI assistant that lives directly in your Telegram chats. Instead of only answering text prompts, it can use tools to complete multi-step tasks: run shell commands, read and edit files, search code, browse the web, schedule jobs, and keep persistent memory.</p>
<p>This post is a short project introduction: what MicroClaw is, how it works, and why the architecture is built this way.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="what-problem-it-solves">What problem it solves<a href="https://microclaw.ai/blog/building-microclaw#what-problem-it-solves" class="hash-link" aria-label="Direct link to What problem it solves" title="Direct link to What problem it solves" translate="no">​</a></h2>
<p>Most chat bots are single-turn wrappers around an LLM API: send user text in, send model text out.</p>
<p>MicroClaw uses an agent loop. For each user message, the model can:</p>
<ol>
<li class="">Decide whether to answer directly or call a tool</li>
<li class="">Execute one or more tools</li>
<li class="">Read tool results</li>
<li class="">Continue iterating until the task is complete</li>
</ol>
<p>That loop turns chat from Q&amp;A into execution.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="core-capabilities">Core capabilities<a href="https://microclaw.ai/blog/building-microclaw#core-capabilities" class="hash-link" aria-label="Direct link to Core capabilities" title="Direct link to Core capabilities" translate="no">​</a></h2>
<ul>
<li class="">Tool execution in chat (<code>bash</code>, file ops, <code>glob</code>, <code>grep</code>, web tools)</li>
<li class="">Session resume with full tool-call context persisted in SQLite</li>
<li class="">Context compaction when sessions grow large</li>
<li class="">Persistent memory via global and per-chat <code>CLAUDE.md</code></li>
<li class="">Scheduled tasks (one-shot and cron)</li>
<li class="">Sub-agent execution with a restricted tool set</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="high-level-architecture">High-level architecture<a href="https://microclaw.ai/blog/building-microclaw#high-level-architecture" class="hash-link" aria-label="Direct link to High-level architecture" title="Direct link to High-level architecture" translate="no">​</a></h2>
<p>At a high level, each message flows through the same pipeline:</p>
<ol>
<li class="">Store message in SQLite</li>
<li class="">Load session/history + memory</li>
<li class="">Call LLM with tool definitions</li>
<li class="">If tool use is requested, execute tool and loop</li>
<li class="">When LLM ends turn, return response to chat</li>
</ol>
<p>The same agent loop is reused by the scheduler, so scheduled jobs can also use tools and reasoning.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="why-rust">Why Rust<a href="https://microclaw.ai/blog/building-microclaw#why-rust" class="hash-link" aria-label="Direct link to Why Rust" title="Direct link to Why Rust" translate="no">​</a></h2>
<p>MicroClaw is written in Rust for operational simplicity and reliability:</p>
<ul>
<li class="">Single binary deployment (<code>cargo build --release</code>)</li>
<li class="">Strong typing for message blocks (<code>text</code>, <code>tool_use</code>, <code>tool_result</code>)</li>
<li class="">Clear shared-state boundaries (<code>Arc&lt;Database&gt;</code>)</li>
<li class="">Predictable async runtime behavior with Tokio</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="project-status">Project status<a href="https://microclaw.ai/blog/building-microclaw#project-status" class="hash-link" aria-label="Direct link to Project status" title="Direct link to Project status" translate="no">​</a></h2>
<p>MicroClaw is under active development. Current focus areas are improving onboarding, hardening runtime safety defaults, and making multi-chat operations more robust.</p>
<p>If you want to explore the full docs, start here:</p>
<ul>
<li class=""><a href="https://microclaw.ai/docs/overview" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/overview</a></li>
<li class=""><a href="https://microclaw.ai/docs/architecture" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/architecture</a></li>
<li class=""><a href="https://microclaw.ai/docs/tools" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/tools</a></li>
</ul>]]></content:encoded>
            <category>Architecture</category>
            <category>Rust</category>
            <category>Telegram</category>
            <category>Agentic AI</category>
        </item>
    </channel>
</rss>