<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="rss.xsl"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>MicroClaw Blog</title>
        <link>https://microclaw.ai/blog</link>
        <description>MicroClaw Blog</description>
        <lastBuildDate>Sat, 07 Feb 2026 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Introducing MicroClaw: An Agentic AI Assistant for Telegram]]></title>
            <link>https://microclaw.ai/blog/building-microclaw</link>
            <guid>https://microclaw.ai/blog/building-microclaw</guid>
            <pubDate>Sat, 07 Feb 2026 00:00:00 GMT</pubDate>
            <description><![CDATA[MicroClaw is a Rust-based AI assistant that lives directly in your Telegram chats. Instead of only answering text prompts, it can use tools to complete multi-step tasks: run shell commands, read and edit files, search code, browse the web, schedule jobs, and keep persistent memory.]]></description>
            <content:encoded><![CDATA[<p>MicroClaw is a Rust-based AI assistant that lives directly in your Telegram chats. Instead of only answering text prompts, it can use tools to complete multi-step tasks: run shell commands, read and edit files, search code, browse the web, schedule jobs, and keep persistent memory.</p>
<p>This post is a short project introduction: what MicroClaw is, how it works, and why the architecture is built this way.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="what-problem-it-solves">What problem it solves<a href="https://microclaw.ai/blog/building-microclaw#what-problem-it-solves" class="hash-link" aria-label="Direct link to What problem it solves" title="Direct link to What problem it solves" translate="no">​</a></h2>
<p>Most chat bots are single-turn wrappers around an LLM API: send user text in, send model text out.</p>
<p>MicroClaw uses an agent loop. For each user message, the model can:</p>
<ol>
<li class="">Decide whether to answer directly or call a tool</li>
<li class="">Execute one or more tools</li>
<li class="">Read tool results</li>
<li class="">Continue iterating until the task is complete</li>
</ol>
<p>That loop turns chat from Q&amp;A into execution.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="core-capabilities">Core capabilities<a href="https://microclaw.ai/blog/building-microclaw#core-capabilities" class="hash-link" aria-label="Direct link to Core capabilities" title="Direct link to Core capabilities" translate="no">​</a></h2>
<ul>
<li class="">Tool execution in chat (<code>bash</code>, file ops, <code>glob</code>, <code>grep</code>, web tools)</li>
<li class="">Session resume with full tool-call context persisted in SQLite</li>
<li class="">Context compaction when sessions grow large</li>
<li class="">Persistent memory via global and per-chat <code>CLAUDE.md</code></li>
<li class="">Scheduled tasks (one-shot and cron)</li>
<li class="">Sub-agent execution with a restricted tool set</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="high-level-architecture">High-level architecture<a href="https://microclaw.ai/blog/building-microclaw#high-level-architecture" class="hash-link" aria-label="Direct link to High-level architecture" title="Direct link to High-level architecture" translate="no">​</a></h2>
<p>At a high level, each message flows through the same pipeline:</p>
<ol>
<li class="">Store message in SQLite</li>
<li class="">Load session/history + memory</li>
<li class="">Call LLM with tool definitions</li>
<li class="">If tool use is requested, execute tool and loop</li>
<li class="">When LLM ends turn, return response to chat</li>
</ol>
<p>The same agent loop is reused by the scheduler, so scheduled jobs can also use tools and reasoning.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="why-rust">Why Rust<a href="https://microclaw.ai/blog/building-microclaw#why-rust" class="hash-link" aria-label="Direct link to Why Rust" title="Direct link to Why Rust" translate="no">​</a></h2>
<p>MicroClaw is written in Rust for operational simplicity and reliability:</p>
<ul>
<li class="">Single binary deployment (<code>cargo build --release</code>)</li>
<li class="">Strong typing for message blocks (<code>text</code>, <code>tool_use</code>, <code>tool_result</code>)</li>
<li class="">Clear shared-state boundaries (<code>Arc&lt;Database&gt;</code>)</li>
<li class="">Predictable async runtime behavior with Tokio</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="project-status">Project status<a href="https://microclaw.ai/blog/building-microclaw#project-status" class="hash-link" aria-label="Direct link to Project status" title="Direct link to Project status" translate="no">​</a></h2>
<p>MicroClaw is under active development. Current focus areas are improving onboarding, hardening runtime safety defaults, and making multi-chat operations more robust.</p>
<p>If you want to explore the full docs, start here:</p>
<ul>
<li class=""><a href="https://microclaw.ai/docs/overview" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/overview</a></li>
<li class=""><a href="https://microclaw.ai/docs/architecture" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/architecture</a></li>
<li class=""><a href="https://microclaw.ai/docs/tools" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/tools</a></li>
</ul>]]></content:encoded>
            <category>Architecture</category>
            <category>Rust</category>
            <category>telegram</category>
            <category>Agentic AI</category>
        </item>
    </channel>
</rss>