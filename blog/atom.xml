<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://microclaw.ai/blog</id>
    <title>MicroClaw Blog</title>
    <updated>2026-02-08T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://microclaw.ai/blog"/>
    <subtitle>MicroClaw Blog</subtitle>
    <icon>https://microclaw.ai/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[MicroClaw vs NanoClaw vs OpenClaw: Three Paths from Minimalism to Platform]]></title>
        <id>https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw</id>
        <link href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw"/>
        <updated>2026-02-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[If you are building a personal AI assistant that lives inside chat apps, you usually end up on one of three paths:]]></summary>
        <content type="html"><![CDATA[<p>If you are building a personal AI assistant that lives inside chat apps, you usually end up on one of three paths:</p>
<ol>
<li class="">Minimal and understandable, with isolation first</li>
<li class="">Feature-rich and multi-platform, with ecosystem breadth first</li>
<li class="">A middle path with practical built-ins and controlled complexity</li>
</ol>
<p>MicroClaw, NanoClaw, and OpenClaw each sit at different points on that spectrum.</p>
<p>This post compares the three from an engineering perspective, based on publicly available repositories and docs as of February 8, 2026.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="tldr">TL;DR<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#tldr" class="hash-link" aria-label="Direct link to TL;DR" title="Direct link to TL;DR" translate="no">​</a></h2>
<ul>
<li class="">If your top priority is minimal code and container isolation, NanoClaw is a strong fit.</li>
<li class="">If you want a full personal AI platform (many channels, nodes, voice, canvas, control plane), OpenClaw is stronger.</li>
<li class="">If you want a Telegram-first assistant that is practical, maintainable, and feature-complete for daily use, MicroClaw is the more balanced choice.</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="at-a-glance-engineering-view">At a Glance (Engineering View)<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#at-a-glance-engineering-view" class="hash-link" aria-label="Direct link to At a Glance (Engineering View)" title="Direct link to At a Glance (Engineering View)" translate="no">​</a></h2>
<table><thead><tr><th>Dimension</th><th>NanoClaw</th><th>OpenClaw</th><th>MicroClaw</th></tr></thead><tbody><tr><td>Product orientation</td><td>Single-user, minimal, highly understandable</td><td>Personal AI platform (control plane + multi-surface ecosystem)</td><td>Practical chat agent, Telegram-first</td></tr><tr><td>Primary stack</td><td>Node.js + Claude Agent SDK</td><td>TypeScript/Node.js platform architecture</td><td>Rust + Tokio + teloxide</td></tr><tr><td>Default channel</td><td>WhatsApp-first</td><td>Multi-channel (WA/Telegram/Slack/Discord/...)</td><td>Telegram-first (optional WhatsApp webhook, Discord)</td></tr><tr><td>Model strategy</td><td>Closely coupled to Claude Code/Agent SDK workflow</td><td>Multi-provider strategy with failover concepts</td><td>Native Anthropic + OpenAI-compatible abstraction</td></tr><tr><td>Tool execution</td><td>Containerized execution as core principle</td><td>Broad tool ecosystem (browser/canvas/nodes/cron, etc.)</td><td>Built-in tool registry + sub-agent + skills + todo</td></tr><tr><td>Session model</td><td>README emphasizes simplicity/isolation</td><td>Platform-level session/gateway/WS control plane</td><td>Full session persistence (including <code>tool_use</code> / <code>tool_result</code>)</td></tr><tr><td>Context management</td><td>More skill-driven extension approach</td><td>Built-in pruning/session management capabilities</td><td>Built-in context compaction for long sessions</td></tr><tr><td>Security emphasis</td><td>OS-level isolation (Apple Container/Docker)</td><td>Gateway policy + pairing/allowlist + platform controls</td><td>App-level auth + chat-level access control + hardening path</td></tr><tr><td>Deployment shape</td><td>Claude-driven setup + container dependency</td><td>CLI + daemon + companion app/node</td><td>Rust single-binary deployment</td></tr><tr><td>Best fit</td><td>Builders who want full control of a minimal core</td><td>Users who want a maximal capability platform</td><td>Developers who want practical features with maintainable complexity</td></tr></tbody></table>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="why-microclaw-is-not-another-openclaw">Why MicroClaw Is Not “Another OpenClaw”<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#why-microclaw-is-not-another-openclaw" class="hash-link" aria-label="Direct link to Why MicroClaw Is Not “Another OpenClaw”" title="Direct link to Why MicroClaw Is Not “Another OpenClaw”" translate="no">​</a></h2>
<p>OpenClaw has gone very deep on the “personal AI platform” direction: multi-channel support, gateway control plane, nodes, voice, canvas, web surfaces, remote access, and skill ecosystem.</p>
<p>That is not inherently good or bad. It is a complexity budget decision.</p>
<p>MicroClaw makes different tradeoffs:</p>
<ul>
<li class="">It does not try to cover every surface at once; it optimizes the Telegram path first.</li>
<li class="">It does not build a heavy control plane first; it prioritizes a robust agent loop, tool execution, session recovery, scheduling, and memory.</li>
<li class="">It uses Rust and a straightforward process model to reduce hidden runtime state.</li>
</ul>
<p>So it is not copying OpenClaw. It is optimizing for a different complexity tier.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="why-microclaw-is-not-nanoclaw-in-rust">Why MicroClaw Is Not “NanoClaw in Rust”<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#why-microclaw-is-not-nanoclaw-in-rust" class="hash-link" aria-label="Direct link to Why MicroClaw Is Not “NanoClaw in Rust”" title="Direct link to Why MicroClaw Is Not “NanoClaw in Rust”" translate="no">​</a></h2>
<p>NanoClaw’s value proposition is clear: keep the core tiny, understandable, and isolation-first, then customize through skills instead of bloating the base.</p>
<p>MicroClaw shares the “personal assistant should be controllable” philosophy, but applies it differently:</p>
<ul>
<li class="">NanoClaw emphasizes minimizing infrastructure.</li>
<li class="">MicroClaw emphasizes practical built-ins for daily use, including:<!-- -->
<ul>
<li class="">Full session resume with tool interaction context</li>
<li class="">Built-in context compaction</li>
<li class="">Sub-agents with restricted tool sets</li>
<li class="">Planning/todo tools</li>
<li class="">On-demand skill activation</li>
</ul>
</li>
</ul>
<p>In short: NanoClaw pushes minimal core purity; MicroClaw adds one practical layer above that core.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-core-difference-where-you-place-complexity">The Core Difference: Where You Place Complexity<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#the-core-difference-where-you-place-complexity" class="hash-link" aria-label="Direct link to The Core Difference: Where You Place Complexity" title="Direct link to The Core Difference: Where You Place Complexity" translate="no">​</a></h2>
<p>In personal AI assistants, complexity does not disappear. You choose where it lives.</p>
<ul>
<li class="">NanoClaw puts complexity into your fork-level customization workflow.</li>
<li class="">OpenClaw puts complexity into platform breadth and ecosystem depth.</li>
<li class="">MicroClaw puts complexity into built-in high-frequency features while keeping the architecture traceable.</li>
</ul>
<p>That is why all three can succeed and coexist.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="selection-guide-by-real-use-case">Selection Guide by Real Use Case<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#selection-guide-by-real-use-case" class="hash-link" aria-label="Direct link to Selection Guide by Real Use Case" title="Direct link to Selection Guide by Real Use Case" translate="no">​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="choose-nanoclaw-if">Choose NanoClaw if:<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#choose-nanoclaw-if" class="hash-link" aria-label="Direct link to Choose NanoClaw if:" title="Direct link to Choose NanoClaw if:" translate="no">​</a></h3>
<ul>
<li class="">You strongly prioritize container isolation boundaries.</li>
<li class="">You are comfortable adding capabilities via skills and fork-level changes.</li>
<li class="">You want to understand the core code path quickly.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="choose-openclaw-if">Choose OpenClaw if:<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#choose-openclaw-if" class="hash-link" aria-label="Direct link to Choose OpenClaw if:" title="Direct link to Choose OpenClaw if:" translate="no">​</a></h3>
<ul>
<li class="">You need unified access across many channels and device nodes.</li>
<li class="">You care about voice, canvas, remote gateway, and platform-grade automation.</li>
<li class="">You are willing to pay higher ops/config complexity for a higher feature ceiling.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="choose-microclaw-if">Choose MicroClaw if:<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#choose-microclaw-if" class="hash-link" aria-label="Direct link to Choose MicroClaw if:" title="Direct link to Choose MicroClaw if:" translate="no">​</a></h3>
<ul>
<li class="">Telegram is your primary interface and you want fast time-to-value.</li>
<li class="">You need tool execution + automation, but also robust session recovery and context management.</li>
<li class="">You want a better balance between capability and maintainability.</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="what-microclaw-should-do-next">What MicroClaw Should Do Next<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#what-microclaw-should-do-next" class="hash-link" aria-label="Direct link to What MicroClaw Should Do Next" title="Direct link to What MicroClaw Should Do Next" translate="no">​</a></h2>
<p>Based on this comparison, the next high-leverage steps for MicroClaw are not random feature additions:</p>
<ol>
<li class="">Strengthen default safety boundaries for high-risk tools</li>
<li class="">Improve behavior consistency across channels (Telegram/WhatsApp/Discord)</li>
<li class="">Clarify skill/tool boundaries to reduce prompt overhead and misuse</li>
<li class="">Improve observability for scheduler/session/tool failures</li>
</ol>
<p>The goal is not to become OpenClaw. The goal is to make the “mid-complexity, high-utility assistant” category more reliable.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="final-take">Final Take<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#final-take" class="hash-link" aria-label="Direct link to Final Take" title="Direct link to Final Take" translate="no">​</a></h2>
<p>This is not a “which one is best” debate. It is a “what kind of assistant do you want to operate” decision.</p>
<ul>
<li class="">If you want a controllable scalpel: NanoClaw</li>
<li class="">If you want a powerful workstation platform: OpenClaw</li>
<li class="">If you want a dependable daily engineering vehicle: MicroClaw</li>
</ul>
<p>Choosing the right path matters more than chasing feature trends.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="references">References<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw-openclaw#references" class="hash-link" aria-label="Direct link to References" title="Direct link to References" translate="no">​</a></h2>
<ul>
<li class="">NanoClaw: <a href="https://github.com/gavrielc/nanoclaw" target="_blank" rel="noopener noreferrer" class="">https://github.com/gavrielc/nanoclaw</a></li>
<li class="">NanoClaw README: <a href="https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md" target="_blank" rel="noopener noreferrer" class="">https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md</a></li>
<li class="">OpenClaw: <a href="https://github.com/openclaw/openclaw" target="_blank" rel="noopener noreferrer" class="">https://github.com/openclaw/openclaw</a></li>
<li class="">OpenClaw Docs: <a href="https://docs.openclaw.ai/" target="_blank" rel="noopener noreferrer" class="">https://docs.openclaw.ai</a></li>
<li class="">MicroClaw: <a href="https://github.com/microclaw/microclaw" target="_blank" rel="noopener noreferrer" class="">https://github.com/microclaw/microclaw</a></li>
</ul>]]></content>
        <author>
            <name>Everett</name>
            <uri>https://github.com/microclaw</uri>
        </author>
        <category label="Architecture" term="Architecture"/>
        <category label="Rust" term="Rust"/>
        <category label="Telegram" term="Telegram"/>
        <category label="Agentic AI" term="Agentic AI"/>
        <category label="Comparison" term="Comparison"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[MicroClaw vs NanoClaw: A Practical Comparison]]></title>
        <id>https://microclaw.ai/blog/microclaw-vs-nanoclaw</id>
        <link href="https://microclaw.ai/blog/microclaw-vs-nanoclaw"/>
        <updated>2026-02-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[MicroClaw was inspired by NanoClaw. They share the same core idea: an AI assistant that can execute tools from chat.]]></summary>
        <content type="html"><![CDATA[<p>MicroClaw was inspired by <a href="https://github.com/gavrielc/nanoclaw/" target="_blank" rel="noopener noreferrer" class="">NanoClaw</a>. They share the same core idea: an AI assistant that can execute tools from chat.</p>
<p>This post compares the two projects from an engineering and product perspective, based on current public documentation.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="scope-note">Scope note<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw#scope-note" class="hash-link" aria-label="Direct link to Scope note" title="Direct link to Scope note" translate="no">​</a></h2>
<p>The NanoClaw side of this comparison is based on its official README as of February 8, 2026. If NanoClaw changes later, some rows may evolve.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="comparison-table">Comparison table<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw#comparison-table" class="hash-link" aria-label="Direct link to Comparison table" title="Direct link to Comparison table" translate="no">​</a></h2>
<table><thead><tr><th>Dimension</th><th>NanoClaw</th><th>MicroClaw</th></tr></thead><tbody><tr><td>Project orientation</td><td>Minimal, single-user, "small enough to understand"</td><td>Broader chat-agent feature set for practical daily use</td></tr><tr><td>Relationship</td><td>Original project</td><td>Inspired by NanoClaw and expanded for Rust + Telegram workflows</td></tr><tr><td>Default channel</td><td>WhatsApp-first</td><td>Telegram-first (with optional WhatsApp Cloud webhook support)</td></tr><tr><td>Multi-channel philosophy</td><td>Prefer transformation skills (for example <code>/add-telegram</code>) over built-in multi-channel complexity</td><td>Built as a chat-surface bot with Telegram as primary experience</td></tr><tr><td>Primary stack</td><td>Node.js + Claude Agent SDK + container runtime</td><td>Rust + Tokio + teloxide + reqwest</td></tr><tr><td>Model/provider strategy</td><td>Tied to Claude Code / Agent SDK workflow</td><td>Native Anthropic + OpenAI-compatible provider abstraction</td></tr><tr><td>Tool system</td><td>README describes major capabilities (web, scheduling, etc.)</td><td>Explicit tool registry with file, shell, web, memory, scheduler, export, sub-agent, todo, and skills tools</td></tr><tr><td>Agent execution loop</td><td>Agent runs through containerized Claude workflow</td><td>Explicit <code>tool_use</code> / <code>tool_result</code> loop with iteration cap</td></tr><tr><td>Security posture emphasis</td><td>OS-level isolation via Apple Container/Docker sandboxes</td><td>In-app tool authorization + deployment hardening strategies</td></tr><tr><td>Host access model</td><td>Commands run inside container with mounted scope</td><td>Commands/tools run in runtime environment; boundaries enforced by auth and ops controls</td></tr><tr><td>Persistence</td><td>SQLite</td><td>SQLite (messages, chats, sessions, scheduled tasks, etc.)</td></tr><tr><td>Session continuity</td><td>Persistent behavior implied; less emphasis on tool-block replay details in README</td><td>Full session resume including tool interaction context</td></tr><tr><td>Context compaction</td><td>Mentioned as a skill direction (<code>/add-clear</code>)</td><td>Built-in context compaction for oversized sessions</td></tr><tr><td>Memory structure</td><td>Per-group <code>CLAUDE.md</code> with isolation focus</td><td>Global + per-chat <code>AGENTS.md</code> scopes</td></tr><tr><td>Scheduler</td><td>Recurring task support</td><td>One-shot + cron recurring tasks with management tools</td></tr><tr><td>Sub-agent capability</td><td>Not explicitly documented in README</td><td>Built-in <code>sub_agent</code> with restricted tool set</td></tr><tr><td>Planning/todo tools</td><td>Not explicitly documented in README</td><td>Built-in todo read/write tools</td></tr><tr><td>Extensibility model</td><td>"Skills over features" is a core principle</td><td>Supports skill activation while also shipping broader built-in capabilities</td></tr><tr><td>Configuration philosophy</td><td>Fewer knobs; customize by code changes</td><td>Config-driven runtime with provider/model/authorization options</td></tr><tr><td>Deployment shape</td><td>Claude Code-centric + container requirements</td><td>Single-binary Rust deployment path (<code>cargo build --release</code>)</td></tr><tr><td>Best fit</td><td>Users who want container-isolated, minimal, deeply personalized forks</td><td>Users who want rich Telegram-native agent workflows with built-in operational features</td></tr></tbody></table>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="bottom-line">Bottom line<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw#bottom-line" class="hash-link" aria-label="Direct link to Bottom line" title="Direct link to Bottom line" translate="no">​</a></h2>
<p>NanoClaw optimizes for minimalism and container isolation first.</p>
<p>MicroClaw optimizes for built-in capability breadth and Telegram-first agent workflows.</p>
<p>Both are valid choices. The right one depends on whether your top priority is minimal isolated substrate (NanoClaw) or broader integrated functionality out of the box (MicroClaw).</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="references">References<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw#references" class="hash-link" aria-label="Direct link to References" title="Direct link to References" translate="no">​</a></h2>
<ul>
<li class="">NanoClaw repository: <a href="https://github.com/gavrielc/nanoclaw/" target="_blank" rel="noopener noreferrer" class="">https://github.com/gavrielc/nanoclaw/</a></li>
<li class="">NanoClaw README (raw): <a href="https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md" target="_blank" rel="noopener noreferrer" class="">https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md</a></li>
<li class="">MicroClaw repository: <a href="https://github.com/microclaw/microclaw" target="_blank" rel="noopener noreferrer" class="">https://github.com/microclaw/microclaw</a></li>
<li class="">MicroClaw docs: <a href="https://microclaw.ai/docs/overview" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/overview</a></li>
</ul>]]></content>
        <author>
            <name>Everett</name>
            <uri>https://github.com/microclaw</uri>
        </author>
        <category label="Architecture" term="Architecture"/>
        <category label="Rust" term="Rust"/>
        <category label="Chat" term="Chat"/>
        <category label="Agentic AI" term="Agentic AI"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building MicroClaw: A Practical Agentic Assistant for Telegram]]></title>
        <id>https://microclaw.ai/blog/building-microclaw</id>
        <link href="https://microclaw.ai/blog/building-microclaw"/>
        <updated>2026-02-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[MicroClaw is a Rust-based AI assistant that lives directly in your chats. It is built for one specific goal: turn chat into a reliable execution surface, not just a text interface.]]></summary>
        <content type="html"><![CDATA[<p>MicroClaw is a Rust-based AI assistant that lives directly in your chats. It is built for one specific goal: turn chat into a reliable execution surface, not just a text interface.</p>
<p>MicroClaw can run shell commands, read and edit files, search code, browse the web, schedule recurring tasks, and maintain persistent memory. It is Telegram-first today, with optional WhatsApp and Discord paths, and it is designed to stay understandable as it grows.</p>
<p>This post is a full introduction to the project: where the idea came from, what design decisions shaped it, and how the architecture works in practice.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="where-the-idea-came-from">Where the Idea Came From<a href="https://microclaw.ai/blog/building-microclaw#where-the-idea-came-from" class="hash-link" aria-label="Direct link to Where the Idea Came From" title="Direct link to Where the Idea Came From" translate="no">​</a></h2>
<p>MicroClaw was inspired by two things happening at the same time:</p>
<ol>
<li class="">The rise of <strong>NanoClaw</strong>, which proved that personal AI assistants should be understandable, self-hostable, and opinionated.</li>
<li class="">The release wave around <strong>Claude Opus 4.6</strong>, which made long-context, tool-heavy assistant workflows feel much more practical for real daily use.</li>
</ol>
<p>NanoClaw showed that small and focused systems can be powerful. Opus 4.6 showed that model capability had reached a point where multi-step reasoning with tools could be trustworthy enough to build on.</p>
<p>MicroClaw started as a question:<br>
<!-- -->Can we keep the spirit of NanoClaw, but build a Telegram-first assistant in Rust with stronger session continuity, operational stability, and practical built-ins?</p>
<p>The answer became this project.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-problem-microclaw-solves">The Problem MicroClaw Solves<a href="https://microclaw.ai/blog/building-microclaw#the-problem-microclaw-solves" class="hash-link" aria-label="Direct link to The Problem MicroClaw Solves" title="Direct link to The Problem MicroClaw Solves" translate="no">​</a></h2>
<p>Most chat bots are still single-turn wrappers:</p>
<ul>
<li class="">user sends text</li>
<li class="">model returns text</li>
<li class="">conversation state is shallow</li>
<li class="">no durable execution context</li>
</ul>
<p>That is fine for Q&amp;A, but weak for real work.</p>
<p>MicroClaw treats each message as an <strong>agentic task loop</strong>. For each incoming message, the model can:</p>
<ol>
<li class="">Decide whether to answer directly or use tools</li>
<li class="">Execute one or more tools</li>
<li class="">Read tool outputs</li>
<li class="">Keep iterating until the task is done</li>
<li class="">Persist the state for the next turn</li>
</ol>
<p>This turns chat from “ask and answer” into “plan, execute, and continue.”</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="what-makes-microclaw-different">What Makes MicroClaw Different<a href="https://microclaw.ai/blog/building-microclaw#what-makes-microclaw-different" class="hash-link" aria-label="Direct link to What Makes MicroClaw Different" title="Direct link to What Makes MicroClaw Different" translate="no">​</a></h2>
<p>MicroClaw is designed around four practical requirements.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="1-durable-conversations-not-stateless-prompts">1) Durable conversations, not stateless prompts<a href="https://microclaw.ai/blog/building-microclaw#1-durable-conversations-not-stateless-prompts" class="hash-link" aria-label="Direct link to 1) Durable conversations, not stateless prompts" title="Direct link to 1) Durable conversations, not stateless prompts" translate="no">​</a></h3>
<p>Sessions are persisted in SQLite with full tool context (<code>tool_use</code> and <code>tool_result</code> blocks).<br>
<!-- -->When a new message arrives, the assistant can resume from real prior execution state, not just a truncated chat summary.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="2-memory-that-can-evolve-over-time">2) Memory that can evolve over time<a href="https://microclaw.ai/blog/building-microclaw#2-memory-that-can-evolve-over-time" class="hash-link" aria-label="Direct link to 2) Memory that can evolve over time" title="Direct link to 2) Memory that can evolve over time" translate="no">​</a></h3>
<p>MicroClaw supports global and per-chat <code>AGENTS.md</code> memory.
The assistant can read and update memory through tools, so preferences and project context survive across days or weeks.</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="3-operational-features-built-in">3) Operational features built in<a href="https://microclaw.ai/blog/building-microclaw#3-operational-features-built-in" class="hash-link" aria-label="Direct link to 3) Operational features built in" title="Direct link to 3) Operational features built in" translate="no">​</a></h3>
<p>It includes production-relevant features out of the box:</p>
<ul>
<li class="">context compaction for oversized sessions</li>
<li class="">scheduled one-shot and recurring tasks</li>
<li class="">continuous typing indicator during long tool loops</li>
<li class="">group catch-up behavior for mention-based activation</li>
<li class="">message splitting for platform limits</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="4-controlled-delegation">4) Controlled delegation<a href="https://microclaw.ai/blog/building-microclaw#4-controlled-delegation" class="hash-link" aria-label="Direct link to 4) Controlled delegation" title="Direct link to 4) Controlled delegation" translate="no">​</a></h3>
<p>MicroClaw includes a <code>sub_agent</code> tool that launches a restricted inner agent with a reduced tool set.<br>
<!-- -->This allows decomposition of complex work while keeping clear safety boundaries.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="core-capabilities">Core Capabilities<a href="https://microclaw.ai/blog/building-microclaw#core-capabilities" class="hash-link" aria-label="Direct link to Core Capabilities" title="Direct link to Core Capabilities" translate="no">​</a></h2>
<ul>
<li class="">Chat-native tool execution (<code>bash</code>, file operations, <code>glob</code>, <code>grep</code>, web search/fetch)</li>
<li class="">Persistent session resume including tool interaction history</li>
<li class="">Context compaction for long-running sessions</li>
<li class="">Global + per-chat persistent memory via <code>AGENTS.md</code></li>
<li class="">Scheduler for cron and one-time tasks</li>
<li class="">Skill activation for domain-specific instructions</li>
<li class="">Todo/plan tools for structured multi-step execution</li>
<li class="">Optional cross-surface integrations (Telegram-first, plus optional WhatsApp/Discord)</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="high-level-architecture">High-level architecture<a href="https://microclaw.ai/blog/building-microclaw#high-level-architecture" class="hash-link" aria-label="Direct link to High-level architecture" title="Direct link to High-level architecture" translate="no">​</a></h2>
<p>At a high level, every message follows the same execution path:</p>
<ol>
<li class="">Store message in SQLite</li>
<li class="">Load session state, recent history, and memory</li>
<li class="">Call LLM with tool definitions</li>
<li class="">If <code>tool_use</code> is requested, execute tool(s) and loop</li>
<li class="">If <code>end_turn</code>, send response and persist updated session</li>
</ol>
<p>The scheduler reuses this same loop.<br>
<!-- -->That means scheduled tasks are not “dumb reminders” but full agent invocations with tools, reasoning, and memory access.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="why-rust">Why Rust<a href="https://microclaw.ai/blog/building-microclaw#why-rust" class="hash-link" aria-label="Direct link to Why Rust" title="Direct link to Why Rust" translate="no">​</a></h2>
<p>MicroClaw is written in Rust for reliability and operational clarity:</p>
<ul>
<li class="">Single binary deployment (<code>cargo build --release</code>)</li>
<li class="">Strong typing for protocol/message block structures</li>
<li class="">Explicit shared-state boundaries (<code>Arc&lt;Database&gt;</code>)</li>
<li class="">Predictable async behavior via Tokio</li>
<li class="">Lower accidental complexity in long-running bot processes</li>
</ul>
<p>Rust is not used for novelty. It is used because this project is a long-lived process that handles concurrency, persistence, and external APIs continuously.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="design-principles">Design Principles<a href="https://microclaw.ai/blog/building-microclaw#design-principles" class="hash-link" aria-label="Direct link to Design Principles" title="Direct link to Design Principles" translate="no">​</a></h2>
<p>MicroClaw follows a few strict rules:</p>
<ul>
<li class=""><strong>Execution-first</strong>: a useful assistant must do work, not only generate text.</li>
<li class=""><strong>State is a feature</strong>: preserving session and memory quality is as important as model quality.</li>
<li class=""><strong>Simple core, practical edges</strong>: keep architecture small, but include features needed in real daily workflows.</li>
<li class=""><strong>Safety by layers</strong>: combine tool-level checks, chat access controls, and deployment hardening.</li>
<li class=""><strong>Composable growth</strong>: add capabilities via tools and skills without breaking the core loop.</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="example-workflows">Example Workflows<a href="https://microclaw.ai/blog/building-microclaw#example-workflows" class="hash-link" aria-label="Direct link to Example Workflows" title="Direct link to Example Workflows" translate="no">​</a></h2>
<p>Here are the kinds of tasks MicroClaw is designed for:</p>
<ul>
<li class="">“Search this repo for API breaking changes and draft release notes.”</li>
<li class="">“Every weekday at 9am, send me an AI news briefing from selected sources.”</li>
<li class="">“Read this error log, find likely root causes, and propose fixes.”</li>
<li class="">“Remember that I prefer concise responses and Rust code examples.”</li>
<li class="">“Break this migration into a todo plan and execute step by step.”</li>
</ul>
<p>These are not one-shot prompts. They are iterative workflows with context and state.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="project-status">Project status<a href="https://microclaw.ai/blog/building-microclaw#project-status" class="hash-link" aria-label="Direct link to Project status" title="Direct link to Project status" translate="no">​</a></h2>
<p>MicroClaw is under active development. Current priorities are:</p>
<ol>
<li class="">Stronger default safety boundaries for tool execution</li>
<li class="">Better multi-channel consistency across Telegram/WhatsApp/Discord</li>
<li class="">Better observability for scheduler/session/tool failures</li>
<li class="">Smoother onboarding and configuration UX</li>
</ol>
<p>If you want to explore the full docs, start here:</p>
<ul>
<li class=""><a href="https://microclaw.ai/docs/overview" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/overview</a></li>
<li class=""><a href="https://microclaw.ai/docs/architecture" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/architecture</a></li>
<li class=""><a href="https://microclaw.ai/docs/tools" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/tools</a></li>
<li class="">Source code: <a href="https://github.com/microclaw/microclaw" target="_blank" rel="noopener noreferrer" class="">https://github.com/microclaw/microclaw</a></li>
</ul>]]></content>
        <author>
            <name>Everett</name>
            <uri>https://github.com/microclaw</uri>
        </author>
        <category label="Architecture" term="Architecture"/>
        <category label="Rust" term="Rust"/>
        <category label="Telegram" term="Telegram"/>
        <category label="Agentic AI" term="Agentic AI"/>
    </entry>
</feed>