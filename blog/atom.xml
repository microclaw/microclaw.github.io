<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://microclaw.ai/blog</id>
    <title>MicroClaw Blog</title>
    <updated>2026-02-08T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://microclaw.ai/blog"/>
    <subtitle>MicroClaw Blog</subtitle>
    <icon>https://microclaw.ai/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[MicroClaw vs NanoClaw: A Practical Comparison]]></title>
        <id>https://microclaw.ai/blog/microclaw-vs-nanoclaw</id>
        <link href="https://microclaw.ai/blog/microclaw-vs-nanoclaw"/>
        <updated>2026-02-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[MicroClaw was inspired by NanoClaw. They share the same core idea: an AI assistant that can execute tools from chat.]]></summary>
        <content type="html"><![CDATA[<p>MicroClaw was inspired by <a href="https://github.com/gavrielc/nanoclaw/" target="_blank" rel="noopener noreferrer" class="">NanoClaw</a>. They share the same core idea: an AI assistant that can execute tools from chat.</p>
<p>This post compares the two projects from an engineering and product perspective, based on current public documentation.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="scope-note">Scope note<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw#scope-note" class="hash-link" aria-label="Direct link to Scope note" title="Direct link to Scope note" translate="no">​</a></h2>
<p>The NanoClaw side of this comparison is based on its official README as of February 8, 2026. If NanoClaw changes later, some rows may evolve.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="comparison-table">Comparison table<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw#comparison-table" class="hash-link" aria-label="Direct link to Comparison table" title="Direct link to Comparison table" translate="no">​</a></h2>
<table><thead><tr><th>Dimension</th><th>NanoClaw</th><th>MicroClaw</th></tr></thead><tbody><tr><td>Project orientation</td><td>Minimal, single-user, "small enough to understand"</td><td>Broader chat-agent feature set for practical daily use</td></tr><tr><td>Relationship</td><td>Original project</td><td>Inspired by NanoClaw and expanded for Rust + Telegram workflows</td></tr><tr><td>Default channel</td><td>WhatsApp-first</td><td>Telegram-first (with optional WhatsApp Cloud webhook support)</td></tr><tr><td>Multi-channel philosophy</td><td>Prefer transformation skills (for example <code>/add-telegram</code>) over built-in multi-channel complexity</td><td>Built as a chat-surface bot with Telegram as primary experience</td></tr><tr><td>Primary stack</td><td>Node.js + Claude Agent SDK + container runtime</td><td>Rust + Tokio + teloxide + reqwest</td></tr><tr><td>Model/provider strategy</td><td>Tied to Claude Code / Agent SDK workflow</td><td>Native Anthropic + OpenAI-compatible provider abstraction</td></tr><tr><td>Tool system</td><td>README describes major capabilities (web, scheduling, etc.)</td><td>Explicit tool registry with file, shell, web, memory, scheduler, export, sub-agent, todo, and skills tools</td></tr><tr><td>Agent execution loop</td><td>Agent runs through containerized Claude workflow</td><td>Explicit <code>tool_use</code> / <code>tool_result</code> loop with iteration cap</td></tr><tr><td>Security posture emphasis</td><td>OS-level isolation via Apple Container/Docker sandboxes</td><td>In-app tool authorization + deployment hardening strategies</td></tr><tr><td>Host access model</td><td>Commands run inside container with mounted scope</td><td>Commands/tools run in runtime environment; boundaries enforced by auth and ops controls</td></tr><tr><td>Persistence</td><td>SQLite</td><td>SQLite (messages, chats, sessions, scheduled tasks, etc.)</td></tr><tr><td>Session continuity</td><td>Persistent behavior implied; less emphasis on tool-block replay details in README</td><td>Full session resume including tool interaction context</td></tr><tr><td>Context compaction</td><td>Mentioned as a skill direction (<code>/add-clear</code>)</td><td>Built-in context compaction for oversized sessions</td></tr><tr><td>Memory structure</td><td>Per-group <code>CLAUDE.md</code> with isolation focus</td><td>Global + per-chat <code>CLAUDE.md</code> scopes</td></tr><tr><td>Scheduler</td><td>Recurring task support</td><td>One-shot + cron recurring tasks with management tools</td></tr><tr><td>Sub-agent capability</td><td>Not explicitly documented in README</td><td>Built-in <code>sub_agent</code> with restricted tool set</td></tr><tr><td>Planning/todo tools</td><td>Not explicitly documented in README</td><td>Built-in todo read/write tools</td></tr><tr><td>Extensibility model</td><td>"Skills over features" is a core principle</td><td>Supports skill activation while also shipping broader built-in capabilities</td></tr><tr><td>Configuration philosophy</td><td>Fewer knobs; customize by code changes</td><td>Config-driven runtime with provider/model/authorization options</td></tr><tr><td>Deployment shape</td><td>Claude Code-centric + container requirements</td><td>Single-binary Rust deployment path (<code>cargo build --release</code>)</td></tr><tr><td>Best fit</td><td>Users who want container-isolated, minimal, deeply personalized forks</td><td>Users who want rich Telegram-native agent workflows with built-in operational features</td></tr></tbody></table>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="bottom-line">Bottom line<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw#bottom-line" class="hash-link" aria-label="Direct link to Bottom line" title="Direct link to Bottom line" translate="no">​</a></h2>
<p>NanoClaw optimizes for minimalism and container isolation first.</p>
<p>MicroClaw optimizes for built-in capability breadth and Telegram-first agent workflows.</p>
<p>Both are valid choices. The right one depends on whether your top priority is minimal isolated substrate (NanoClaw) or broader integrated functionality out of the box (MicroClaw).</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="references">References<a href="https://microclaw.ai/blog/microclaw-vs-nanoclaw#references" class="hash-link" aria-label="Direct link to References" title="Direct link to References" translate="no">​</a></h2>
<ul>
<li class="">NanoClaw repository: <a href="https://github.com/gavrielc/nanoclaw/" target="_blank" rel="noopener noreferrer" class="">https://github.com/gavrielc/nanoclaw/</a></li>
<li class="">NanoClaw README (raw): <a href="https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md" target="_blank" rel="noopener noreferrer" class="">https://raw.githubusercontent.com/gavrielc/nanoclaw/main/README.md</a></li>
<li class="">MicroClaw repository: <a href="https://github.com/microclaw/microclaw" target="_blank" rel="noopener noreferrer" class="">https://github.com/microclaw/microclaw</a></li>
<li class="">MicroClaw docs: <a href="https://microclaw.ai/docs/overview" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/overview</a></li>
</ul>]]></content>
        <author>
            <name>Everett</name>
            <uri>https://github.com/microclaw</uri>
        </author>
        <category label="Architecture" term="Architecture"/>
        <category label="Rust" term="Rust"/>
        <category label="Chat" term="Chat"/>
        <category label="Agentic AI" term="Agentic AI"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Introducing MicroClaw: An Agentic AI Assistant for Telegram]]></title>
        <id>https://microclaw.ai/blog/building-microclaw</id>
        <link href="https://microclaw.ai/blog/building-microclaw"/>
        <updated>2026-02-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[MicroClaw is a Rust-based AI assistant that lives directly in your Telegram chats. Instead of only answering text prompts, it can use tools to complete multi-step tasks: run shell commands, read and edit files, search code, browse the web, schedule jobs, and keep persistent memory.]]></summary>
        <content type="html"><![CDATA[<p>MicroClaw is a Rust-based AI assistant that lives directly in your Telegram chats. Instead of only answering text prompts, it can use tools to complete multi-step tasks: run shell commands, read and edit files, search code, browse the web, schedule jobs, and keep persistent memory.</p>
<p>This post is a short project introduction: what MicroClaw is, how it works, and why the architecture is built this way.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="what-problem-it-solves">What problem it solves<a href="https://microclaw.ai/blog/building-microclaw#what-problem-it-solves" class="hash-link" aria-label="Direct link to What problem it solves" title="Direct link to What problem it solves" translate="no">​</a></h2>
<p>Most chat bots are single-turn wrappers around an LLM API: send user text in, send model text out.</p>
<p>MicroClaw uses an agent loop. For each user message, the model can:</p>
<ol>
<li class="">Decide whether to answer directly or call a tool</li>
<li class="">Execute one or more tools</li>
<li class="">Read tool results</li>
<li class="">Continue iterating until the task is complete</li>
</ol>
<p>That loop turns chat from Q&amp;A into execution.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="core-capabilities">Core capabilities<a href="https://microclaw.ai/blog/building-microclaw#core-capabilities" class="hash-link" aria-label="Direct link to Core capabilities" title="Direct link to Core capabilities" translate="no">​</a></h2>
<ul>
<li class="">Tool execution in chat (<code>bash</code>, file ops, <code>glob</code>, <code>grep</code>, web tools)</li>
<li class="">Session resume with full tool-call context persisted in SQLite</li>
<li class="">Context compaction when sessions grow large</li>
<li class="">Persistent memory via global and per-chat <code>CLAUDE.md</code></li>
<li class="">Scheduled tasks (one-shot and cron)</li>
<li class="">Sub-agent execution with a restricted tool set</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="high-level-architecture">High-level architecture<a href="https://microclaw.ai/blog/building-microclaw#high-level-architecture" class="hash-link" aria-label="Direct link to High-level architecture" title="Direct link to High-level architecture" translate="no">​</a></h2>
<p>At a high level, each message flows through the same pipeline:</p>
<ol>
<li class="">Store message in SQLite</li>
<li class="">Load session/history + memory</li>
<li class="">Call LLM with tool definitions</li>
<li class="">If tool use is requested, execute tool and loop</li>
<li class="">When LLM ends turn, return response to chat</li>
</ol>
<p>The same agent loop is reused by the scheduler, so scheduled jobs can also use tools and reasoning.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="why-rust">Why Rust<a href="https://microclaw.ai/blog/building-microclaw#why-rust" class="hash-link" aria-label="Direct link to Why Rust" title="Direct link to Why Rust" translate="no">​</a></h2>
<p>MicroClaw is written in Rust for operational simplicity and reliability:</p>
<ul>
<li class="">Single binary deployment (<code>cargo build --release</code>)</li>
<li class="">Strong typing for message blocks (<code>text</code>, <code>tool_use</code>, <code>tool_result</code>)</li>
<li class="">Clear shared-state boundaries (<code>Arc&lt;Database&gt;</code>)</li>
<li class="">Predictable async runtime behavior with Tokio</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="project-status">Project status<a href="https://microclaw.ai/blog/building-microclaw#project-status" class="hash-link" aria-label="Direct link to Project status" title="Direct link to Project status" translate="no">​</a></h2>
<p>MicroClaw is under active development. Current focus areas are improving onboarding, hardening runtime safety defaults, and making multi-chat operations more robust.</p>
<p>If you want to explore the full docs, start here:</p>
<ul>
<li class=""><a href="https://microclaw.ai/docs/overview" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/overview</a></li>
<li class=""><a href="https://microclaw.ai/docs/architecture" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/architecture</a></li>
<li class=""><a href="https://microclaw.ai/docs/tools" target="_blank" rel="noopener noreferrer" class="">https://microclaw.ai/docs/tools</a></li>
</ul>]]></content>
        <author>
            <name>Everett</name>
            <uri>https://github.com/microclaw</uri>
        </author>
        <category label="Architecture" term="Architecture"/>
        <category label="Rust" term="Rust"/>
        <category label="Telegram" term="Telegram"/>
        <category label="Agentic AI" term="Agentic AI"/>
    </entry>
</feed>